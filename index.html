<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="forum-title-tag">Negativa Server - FÃ³rum</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background: #10131a; }
        .view { display: none; }
        .active-view { display: block; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #181c24; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #222; }
        .modal {
            position: fixed; z-index: 100; left: 0; top: 0; width: 100vw; height: 100vh;
            overflow: auto; background-color: rgba(0,0,0,0.7); display: flex;
            align-items: center; justify-content: center;
        }
        .modal-content {
            background-color: #181c24; color: #f1f1f1; margin: auto; padding: 20px;
            border: 1px solid #222; width: 90vw; max-width: 500px; border-radius: 18px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            animation: modalIn 0.2s;
        }
        @keyframes modalIn { from { opacity: 0; transform: scale(0.95);} to { opacity: 1; transform: scale(1);} }
        .modal-content-lg { max-width: 95vw; }
        @media (max-width: 640px) {
            .modal-content, .modal-content-lg {
                width: 98vw !important;
                max-width: 98vw !important;
                padding: 10px !important;
            }
        }
        .modal-close {
            color: #aaa; float: right; font-size: 28px; font-weight: bold;
            cursor: pointer;
            outline: none;
        }
        .modal-close:focus {
            outline: 2px solid #facc15 !important;
        }
        .modal-close:hover, .modal-close:focus {
            color: #f87171; text-decoration: none; cursor: pointer;
        }
        .loading-spinner, .gemini-loading-spinner {
            border: 4px solid #23272f; border-top: 4px solid #60a5fa;
            border-radius: 50%; width: 32px; height: 32px;
            animation: spin 1s linear infinite; margin: 16px auto;
        }
        .gemini-loading-spinner {
            width: 18px; height: 18px; border-width: 3px; display: inline-block;
            margin: 0 0 0 8px; vertical-align: middle;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .role-tag {
            padding: 0.1em 0.5em;
            border-radius: 0.4em;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 0.5em;
            color: #fff;
            background-color: #6b7280;
            box-shadow: 0 1px 4px 0 rgba(0,0,0,0.10);
        }
        #chat-messages {
            height: 160px;
            overflow-y: auto;
            border: 1px solid #374151;
            padding: 6px;
            border-radius: 0.5rem;
            margin-bottom: 8px;
            background-color: #23272f;
            scroll-behavior: smooth;
        }
        .chat-message {
            margin-bottom: 2px;
            padding: 2px 0;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .chat-message .username {
            font-weight: bold;
            color: #60a5fa;
        }
        .chat-message .delete-chat-msg-btn {
            background: none;
            border: none;
            color: #f87171;
            cursor: pointer;
            font-size: 0.85rem;
            padding: 0 0.25rem;
            margin-left: 0.5rem;
            border-radius: 4px;
            transition: background 0.15s;
        }
        .chat-message .delete-chat-msg-btn:hover, .chat-message .delete-chat-msg-btn:focus {
            color: #fff;
            background: #f87171;
            outline: 2px solid #facc15 !important;
        }
        .chat-message .delete-chat-msg-btn:focus {
            outline: 2px solid #facc15 !important;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 22px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #374151;
            transition: .4s;
            border-radius: 22px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #4CAF50; }
        input:checked + .slider:before { transform: translateX(22px); }
        .admin-section {
            background-color: rgba(42, 50, 66, 0.7); 
            padding: 1rem; 
            border-radius: 0.7rem; 
            margin-bottom: 1rem; 
            border: 1px solid #374151; 
        }
        .admin-section-title {
            font-size: 1.05rem; 
            font-weight: 600; 
            color: #facc15; 
            margin-bottom: 0.5rem; 
            padding-bottom: 0.25rem; 
            border-bottom: 1px solid #4a5568; 
        }
        #admin-controls { display: none; }
        .edit-topic-btn-icon {
            cursor: pointer;
            margin-left: 8px;
            color: #fbbf24;
            border-radius: 4px;
            transition: background 0.15s;
        }
        .edit-topic-btn-icon:hover, .edit-topic-btn-icon:focus {
            color: #fff;
            background: #fbbf24;
            outline: 2px solid #facc15 !important;
        }
        /* --- MODERN & RESPONSIVE IMPROVEMENTS --- */
        @media (max-width: 640px) {
            header, footer, .container, #main-content {
                padding-left: 4px !important;
                padding-right: 4px !important;
            }
            .max-w-md, .max-w-lg, .max-w-xl {
                max-width: 98vw !important;
            }
            .rounded-lg, .rounded-md {
                border-radius: 14px !important;
            }
            .p-8, .p-6, .p-4 {
                padding: 10px !important;
            }
            .text-2xl, .text-3xl {
                font-size: 1.2rem !important;
            }
            .text-xl {
                font-size: 1rem !important;
            }
            .mb-6, .mb-4, .mb-2 {
                margin-bottom: 10px !important;
            }
            .mt-6, .mt-4, .mt-2 {
                margin-top: 10px !important;
            }
            .py-10 {
                padding-top: 20px !important;
                padding-bottom: 20px !important;
            }
            .shadow-xl, .shadow-md, .shadow {
                box-shadow: 0 2px 8px 0 rgba(31,38,135,0.15) !important;
            }
            .flex, .grid {
                flex-direction: column !important;
            }
            .w-full, .w-48, .w-24, .w-12 {
                width: 100% !important;
            }
            .h-48, .h-24, .h-8 {
                height: auto !important;
            }
            .space-y-4, .space-y-3, .space-y-2, .space-y-1 {
                gap: 6px !important;
            }
        }
        /* Navbar sticky para mobile */
        @media (max-width: 640px) {
            header {
                position: sticky;
                top: 0;
                z-index: 50;
                background: #181c24;
                box-shadow: 0 2px 8px 0 rgba(31,38,135,0.15);
            }
            nav {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                justify-content: center;
            }
        }
        /* Compact cards */
        .bg-gray-800.p-4.rounded-lg.shadow,
        .bg-gray-800.p-4.rounded-lg.shadow.mb-4 {
            padding: 12px !important;
            border-radius: 16px !important;
            box-shadow: 0 2px 8px 0 rgba(31,38,135,0.10) !important;
            margin-bottom: 10px !important;
            background: #181c24 !important;
            border: 1px solid #23272f !important;
        }
        .bg-gray-800.p-6.rounded-lg.shadow-md {
            padding: 14px !important;
            border-radius: 16px !important;
            background: #181c24 !important;
            border: 1px solid #23272f !important;
        }
        /* Compact form inputs */
        input, textarea, select {
            font-size: 1rem !important;
            padding: 10px 12px !important;
            border-radius: 10px !important;
            background: #23272f !important;
            color: #f1f1f1 !important;
            border: 1px solid #374151 !important;
            transition: border 0.15s, box-shadow 0.15s;
        }
        button {
            border-radius: 10px !important;
            font-size: 1.05rem !important;
            min-height: 40px;
            font-weight: 600;
            letter-spacing: 0.01em;
            transition: background 0.15s, color 0.15s, box-shadow 0.15s;
        }
        button:active {
            box-shadow: 0 1px 4px 0 #60a5fa33;
        }
        button:focus {
            outline: 2px solid #facc15 !important;
        }
        /* Modern hover para cards */
        .bg-gray-800.p-4.rounded-lg.shadow:hover, .bg-gray-800.p-4.rounded-lg.shadow:focus-within {
            box-shadow: 0 4px 16px 0 rgba(31,38,135,0.18) !important;
            background: #22262e !important;
            transition: box-shadow 0.2s, background 0.2s;
        }
        /* Modern focus para inputs */
        input:focus, textarea:focus, select:focus {
            outline: 2px solid #60a5fa !important;
            border-color: #60a5fa !important;
            background: #23272f !important;
        }
        /* Hide scrollbars on mobile para main containers */
        @media (max-width: 640px) {
            #main-content, .container, .view {
                overflow-x: hidden !important;
            }
        }
        /* Compact aside */
        aside {
            padding: 8px !important;
            border-radius: 14px !important;
            background: #181c24 !important;
            border: 1px solid #23272f !important;
        }
        /* Compact chat input */
        #chat-message-input {
            font-size: 1rem !important;
            padding: 9px 10px !important;
        }
        /* Compact modal buttons */
        .modal-content button {
            min-width: 80px;
            font-size: 1.05rem !important;
        }
        /* Compact admin panel */
        #admin-controls {
            padding: 10px !important;
            border-radius: 16px !important;
        }
        /* Compact grid gap */
        .grid {
            gap: 10px !important;
        }
        /* Compact topic/post cards */
        .topic-link-container, .bg-gray-800.p-4.rounded-lg.shadow.mb-4 {
            padding: 10px !important;
            border-radius: 14px !important;
        }
        /* Compact form labels */
        label {
            font-size: 1rem !important;
            color: #e5e7eb !important;
            font-weight: 500;
        }
        /* Compact breadcrumbs */
        #breadcrumbs {
            font-size: 0.98rem !important;
            padding-top: 2px !important;
            padding-bottom: 2px !important;
        }
        /* Compact modal close */
        .modal-close {
            font-size: 22px !important;
        }
        /* Feedback visual para sucesso/erro/info */
        .text-green-700, .text-green-700 * { color: #22c55e !important; }
        .text-red-700, .text-red-700 * { color: #ef4444 !important; }
        .text-blue-700, .text-blue-700 * { color: #60a5fa !important; }
        /* Acessibilidade: foco visÃ­vel */
        a:focus, button:focus {
            outline: 2px solid #facc15 !important;
            outline-offset: 2px;
        }
        /* BotÃµes principais mais destacados */
        .bg-blue-600, .bg-green-600, .bg-yellow-500, .bg-purple-600 {
            box-shadow: 0 1px 4px 0 #60a5fa22;
        }
        .bg-blue-600:hover, .bg-green-600:hover, .bg-yellow-500:hover, .bg-purple-600:hover {
            filter: brightness(1.08);
        }
        /* BotÃ£o de logout mais visÃ­vel */
        #logout-nav {
            color: #f87171 !important;
            font-weight: 700;
        }
        #logout-nav:hover, #logout-nav:focus {
            color: #fff !important;
            background: #f87171 !important;
            border-radius: 6px;
            padding: 2px 8px;
            outline: 2px solid #facc15 !important;
        }
        /* Feedback visual para campos obrigatÃ³rios */
        input:required:invalid, textarea:required:invalid {
            border-color: #ef4444 !important;
        }
        /* Corrige espaÃ§amento de Ã­cones e botÃµes */
        .edit-topic-btn-icon, .delete-topic-btn, .delete-category-btn, .edit-post-btn, .delete-post-btn {
            margin-left: 4px !important;
            margin-right: 4px !important;
        }
        /* Melhora visual de links de perfil */
        .user-profile-link {
            color: #60a5fa !important;
            text-decoration: underline dotted;
            cursor: pointer;
        }
        .user-profile-link:hover, .user-profile-link:focus {
            color: #facc15 !important;
            text-decoration: underline;
            outline: 2px solid #facc15 !important;
        }
        /* Melhora visual de tÃ­tulos */
        h1, h2, h3, h4, h5 {
            letter-spacing: 0.01em;
            font-weight: 700;
        }
        /* Melhora visual de listas recentes */
        #recent-members-list ul li {
            padding: 2px 0;
        }
        /* Melhora visual do chat em mobile */
        @media (max-width: 640px) {
            #chat-messages { height: 120px; font-size: 0.95rem; }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import {
            getAuth,
            onAuthStateChanged,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            signInWithCustomToken
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            getDocs,
            doc,
            getDoc,
            setDoc,
            query,
            where,
            Timestamp,
            onSnapshot,
            deleteDoc,
            updateDoc,
            increment,
            orderBy,
            limit,
            runTransaction,
            setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        // Configuration provided by the user (hardcoded as a fallback)
        const userHardcodedFirebaseConfig = {
          apiKey: "AIzaSyCFqjQc4lEj8-djp7frombN_isi_3DVnCM", 
          authDomain: "negativa-af3a2.firebaseapp.com",
          projectId: "negativa-af3a2",
          storageBucket: "negativa-af3a2.appspot.com",
          messagingSenderId: "448951636288",
          appId: "1:448951636288:web:60d1ebb08fcd5b246aaaa5",
          measurementId: "G-GPG4L7TZVE"
        };

        let activeFirebaseConfig = userHardcodedFirebaseConfig;
        let finalInitialAuthToken = undefined; // Will hold the auth token to be used

        // Check for Firebase config provided by the Canvas environment
        const canvasProvidedFirebaseConfigStr = (typeof __firebase_config !== 'undefined' && __firebase_config !== null && String(__firebase_config).trim() !== "" && String(__firebase_config) !== "{}")
            ? String(__firebase_config)
            : null;

        // Check for initial auth token provided by the Canvas environment
        const canvasProvidedInitialAuthToken = (typeof __initial_auth_token !== 'undefined' && __initial_auth_token !== null && String(__initial_auth_token).toLowerCase() !== "undefined" && String(__initial_auth_token).trim() !== "")
            ? String(__initial_auth_token)
            : undefined;

        // Determine which Firebase config and auth token to use
        if (canvasProvidedFirebaseConfigStr && canvasProvidedInitialAuthToken) {
            try {
                activeFirebaseConfig = JSON.parse(canvasProvidedFirebaseConfigStr);
                finalInitialAuthToken = canvasProvidedInitialAuthToken;
                console.log("Using Firebase config and auth token provided by Canvas environment.");
            } catch (e) {
                console.error("Error parsing Canvas-provided Firebase config. Falling back to user's hardcoded config. Custom token from Canvas will NOT be used.", e);
                activeFirebaseConfig = userHardcodedFirebaseConfig;
                finalInitialAuthToken = undefined; // Ensure no Canvas token is used with hardcoded config
            }
        } else if (canvasProvidedInitialAuthToken) {
            // If only token is provided, it might be for a different Firebase project.
            // It's safer to use the user's config and not the token to avoid mismatches.
            console.warn("Canvas custom token detected, but no valid Canvas Firebase config. Using user's hardcoded Firebase config. Canvas token will NOT be used to prevent mismatch.");
            activeFirebaseConfig = userHardcodedFirebaseConfig;
            finalInitialAuthToken = undefined;
        } else {
            // No Canvas config or token, use user's hardcoded values
            console.log("Using user's hardcoded Firebase config. No Canvas custom token or config detected.");
            activeFirebaseConfig = userHardcodedFirebaseConfig;
            finalInitialAuthToken = undefined;
        }
        
        // Determine the App ID for Firestore paths (important for multi-tenant environments)
        const firestorePathAppId = (typeof __app_id !== 'undefined' && String(__app_id).trim() !== "") ? String(__app_id) : activeFirebaseConfig.projectId;
        console.log("Using Firestore Path App ID for Firestore paths:", firestorePathAppId);
        
        // Firebase App Initialization
        let app;
        let auth;
        let db;

        try {
            app = initializeApp(activeFirebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            setLogLevel('debug'); // Enable Firestore debug logging
            console.log("Firebase initialized successfully. Firestore debug logging enabled.");
        } catch (e) {
            console.error("CRITICAL: Firebase initialization failed:", e);
            // Attempt to show an error message to the user if the modal exists
            const errorModal = document.getElementById('message-modal');
            const errorModalText = document.getElementById('message-modal-text');
            if (errorModal && errorModalText) {
                errorModalText.textContent = "Falha crÃ­tica na inicializaÃ§Ã£o do Firebase: " + e.message + ". O aplicativo pode nÃ£o funcionar corretamente.";
                errorModalText.className = 'mb-4 text-red-700'; // Style as error
                errorModal.style.display = 'flex';
            } else {
                // Fallback if modal isn't available (e.g., DOM not fully loaded)
                console.error("Fallback Alert: Falha crÃ­tica na inicializaÃ§Ã£o do Firebase: " + e.message);
            }
        }

        // Global state variables
        let currentUser = null;
        let currentUserId = null;
        let isAdmin = false;
        let userProfileData = null; // To store the current user's profile from Firestore
        let currentRolePermissions = {}; // Permissions for the current user's role

        // Firestore listener unsubscribers
        let unsubscribeCategories = null;
        let unsubscribeTopics = null;
        let unsubscribePosts = null;
        let unsubscribeServerConfig = null;
        let unsubscribeRecentMembers = null;
        let unsubscribeChatMessages = null;
        let unsubscribeCurrentUserProfile = null; // Listener for the current user's own profile
        
        let editingPostId = null; // For editing post content
        let editingTopicId = null; // For editing topic metadata (title, roles)
        let editingTopicData = null; // To store current topic data for the edit modal


        // --- Permissions Constants ---
        const PERMISSIONS = {
            MANAGE_FORUM_SETTINGS: 'canManageForumSettings',
            MANAGE_USERS: 'canManageUsers',
            MANAGE_CATEGORIES: 'canManageCategories',
            CREATE_TOPIC: 'canCreateTopic',
            DELETE_OWN_TOPIC: 'canDeleteOwnTopic',
            DELETE_ANY_TOPIC: 'canDeleteAnyTopic',
            CREATE_POST: 'canCreatePost',
            EDIT_OWN_POST: 'canEditOwnPost',
            EDIT_ANY_POST: 'canEditAnyPost',
            DELETE_OWN_POST: 'canDeleteOwnPost',
            DELETE_ANY_POST: 'canDeleteAnyPost',
            MODERATE_CHAT: 'canModerateChat',
            MANAGE_ROLES_PERMISSIONS: 'canManageRolesPermissions'
            // Consider adding EDIT_ANY_TOPIC if more granular control is needed than MANAGE_CATEGORIES
        };

        // --- Default Roles and Server Configuration Variables ---
        const defaultRoles = ['Admin', 'Moderador', 'VIP', 'Membro']; // Default roles in the system
        let currentRoleColors = {}; // Loaded from serverConfig
        let serverRolePermissionsConfig = {}; // Loaded from serverConfig, defines permissions per role
        let registrationsOpen = true; // Loaded from serverConfig, controls new user registration

        // --- DOM Element Variables ---
        // Views
        const views = {}; // Object to hold all view elements for easy switching
        // Other UI elements
        let forumTitleHeader, forumTitleTag, userDisplay, loginNav, registerNav, logoutNav, myProfileNav, adminControls, adminPanelNav,
            categoriesList, topicsList, postsList, categoryTitle, topicTitleFull, breadcrumbs, currentUserIdDisplay,
            adminUserList, generateCategoryDescBtn, categoryNameInput, categoryDescriptionInput, suggestTopicTitleBtn,
            newTopicContentInput, newTopicTitleInput, newTopicCommandInput, myProfileNicknameInput, myProfileSteamUrlInput,
            myProfileEmailDisplay, myProfileRoleDisplay, myProfileSaveBtn, userProfileViewDisplayName, userProfileViewNickname,
            userProfileViewEmail, userProfileViewRole, userProfileViewSteamLink, userProfileViewRegisteredDate,
            adminRoleColorSettings, saveRoleColorsBtn, adminForumNameInput, saveForumNameBtn, adminRegistrationsToggle,
            saveRegistrationSettingsBtn, csServersListAdmin, addCsServerBtn, csServerModal, csServerForm, csServerIdInput,
            csServerNameInput, csServerConnectInput, cancelCsServerBtn, serverInfoBannerContainer, recentMembersList,
            editPostModal, editPostContentInput, saveEditPostBtn, cancelEditPostBtn, chatMessagesContainer,
            chatMessageInput, sendChatMessageBtn, backToForumFromProfileBtn, adminPermissionsSettings, savePermissionsBtn,
            categoryRolePermissionsAdminContainer, topicRolePermissionsContainer, editTopicModal, editTopicTitleInput, 
            editTopicRolePermissionsContainer, saveEditTopicBtn, cancelEditTopicBtn,
            registerPromptContainer; // Added for the registration link on the login page


        // --- Utility Functions ---
        /**
         * Formats a Firebase Timestamp into a user-friendly relative or absolute date string.
         * @param {Timestamp} firebaseTimestamp - The Firebase Timestamp object.
         * @returns {string} A formatted date string.
         */
        function formatTimestamp(firebaseTimestamp) {
            if (!firebaseTimestamp || typeof firebaseTimestamp.seconds !== 'number') {
                return 'Data invÃ¡lida';
            }
            const date = new Date(firebaseTimestamp.seconds * 1000);
            const now = new Date();
            const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

            if (diffInSeconds < 0) return `em breve`; // For future timestamps, if any
            if (diffInSeconds < 60) return `hÃ¡ ${diffInSeconds} seg`;
            const diffInMinutes = Math.floor(diffInSeconds / 60);
            if (diffInMinutes < 60) return `hÃ¡ ${diffInMinutes} min`;
            const diffInHours = Math.floor(diffInMinutes / 60);
            if (diffInHours < 24) return `hÃ¡ ${diffInHours} h`;

            // For older dates, show full date and time
            const options = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            return date.toLocaleDateString('pt-BR', options);
        }

        /**
         * Checks if the current user has a specific permission based on their role.
         * Admins always have all permissions.
         * @param {string} permissionKey - The key of the permission to check (from PERMISSIONS object).
         * @returns {boolean} True if the user has the permission, false otherwise.
         */
        function hasPermission(permissionKey) {
            if (!userProfileData || !userProfileData.role) {
                return false; // No profile or role, no permissions
            }
            if (userProfileData.role === 'Admin') { // Admins have all permissions
                return true;
            }
            const rolePerms = serverRolePermissionsConfig[userProfileData.role];
            return rolePerms && rolePerms[permissionKey] === true;
        }

        // --- View Management ---
        /**
         * Shows a specific view and hides all others.
         * @param {string} viewName - The name of the view to show (key in the `views` object).
         * @param {object|null} params - Optional parameters for the view (e.g., userId for profile view).
         */
        function showView(viewName, params = null) {
            Object.values(views).forEach(view => view.classList.remove('active-view'));
            if (views[viewName]) {
                views[viewName].classList.add('active-view');
                // Handle specific view loading logic
                if (viewName === 'userProfile' && params && params.userId) {
                    loadUserProfileView(params.userId);
                } else if (viewName === 'myProfile') {
                    loadMyProfileView();
                } else if (viewName === 'login') { 
                    // Ensure the registration prompt on the login page reflects the current server setting
                    if (registerPromptContainer) {
                        registerPromptContainer.style.display = registrationsOpen ? 'block' : 'none';
                    }
                }
            } else {
                console.error(`View ${viewName} not found. Defaulting to login or forum home.`);
                // Fallback to login or forum home if the requested view doesn't exist
                if (currentUser && views.forumHome) views.forumHome.classList.add('active-view');
                else if (views.login) views.login.classList.add('active-view');
            }
            window.scrollTo(0, 0); // Scroll to top when changing views
        }
        
        /**
         * Populates global variables with references to DOM elements.
         * Called once after the DOM is fully loaded.
         */
        function populateDomElementVariables() {
            // Views
            views.loading = document.getElementById('loading-view');
            views.login = document.getElementById('login-view');
            views.register = document.getElementById('register-view');
            views.forumHome = document.getElementById('forum-home-view');
            views.category = document.getElementById('category-view');
            views.topic = document.getElementById('topic-view');
            views.myProfile = document.getElementById('my-profile-view');
            views.userProfile = document.getElementById('user-profile-view');

            // Header & Navigation
            forumTitleHeader = document.getElementById('forum-title-header');
            forumTitleTag = document.getElementById('forum-title-tag');
            userDisplay = document.getElementById('user-display');
            loginNav = document.getElementById('login-nav');
            registerNav = document.getElementById('register-nav');
            logoutNav = document.getElementById('logout-nav');
            myProfileNav = document.getElementById('my-profile-nav');
            adminControls = document.getElementById('admin-controls'); // Admin panel container
            adminPanelNav = document.getElementById('admin-panel-nav'); // Link to toggle admin panel
            breadcrumbs = document.getElementById('breadcrumbs');
            currentUserIdDisplay = document.getElementById('current-user-id-display');
            
            // Forum Content Lists
            categoriesList = document.getElementById('categories-list');
            topicsList = document.getElementById('topics-list');
            postsList = document.getElementById('posts-list');
            categoryTitle = document.getElementById('category-title'); // In category view
            topicTitleFull = document.getElementById('topic-title-full'); // In topic view

            // Admin Panel - General Settings
            adminForumNameInput = document.getElementById('admin-forum-name');
            saveForumNameBtn = document.getElementById('save-forum-name-btn');
            adminRegistrationsToggle = document.getElementById('admin-registrations-toggle');
            saveRegistrationSettingsBtn = document.getElementById('save-registration-settings-btn');
            
            // Admin Panel - Category Creation
            generateCategoryDescBtn = document.getElementById('generate-category-description-btn');
            categoryNameInput = document.getElementById('category-name');
            categoryDescriptionInput = document.getElementById('category-description');
            categoryRolePermissionsAdminContainer = document.getElementById('category-role-permissions-admin-container');

            // Admin Panel - User Management
            adminUserList = document.getElementById('admin-user-list');
            
            // Admin Panel - Role Colors & Permissions
            adminRoleColorSettings = document.getElementById('admin-role-color-settings');
            saveRoleColorsBtn = document.getElementById('save-role-colors-btn');
            adminPermissionsSettings = document.getElementById('admin-permissions-settings');
            savePermissionsBtn = document.getElementById('save-permissions-btn');
            
            // Admin Panel - CS Servers
            csServersListAdmin = document.getElementById('cs-servers-list-admin');
            addCsServerBtn = document.getElementById('add-cs-server-btn');
            csServerModal = document.getElementById('cs-server-modal');
            csServerForm = document.getElementById('cs-server-form');
            csServerIdInput = document.getElementById('cs-server-id'); // Hidden input for edit index
            csServerNameInput = document.getElementById('cs-server-name');
            csServerConnectInput = document.getElementById('cs-server-connect');
            cancelCsServerBtn = document.getElementById('cancel-cs-server');
            serverInfoBannerContainer = document.getElementById('server-info-banner-container'); // Public display

            // Topic Creation (Modal)
            suggestTopicTitleBtn = document.getElementById('suggest-topic-title-btn');
            newTopicContentInput = document.getElementById('new-topic-content');
            newTopicTitleInput = document.getElementById('new-topic-title');
            newTopicCommandInput = document.getElementById('new-topic-command');
            topicRolePermissionsContainer = document.getElementById('topic-role-permissions-container'); // In create topic modal

            // My Profile View
            myProfileNicknameInput = document.getElementById('my-profile-nickname');
            myProfileSteamUrlInput = document.getElementById('my-profile-steam-url');
            myProfileEmailDisplay = document.getElementById('my-profile-email');
            myProfileRoleDisplay = document.getElementById('my-profile-role');
            myProfileSaveBtn = document.getElementById('my-profile-save-btn');

            // User Profile View (Public)
            userProfileViewDisplayName = document.getElementById('user-profile-view-displayName');
            userProfileViewNickname = document.getElementById('user-profile-view-nickname');
            userProfileViewEmail = document.getElementById('user-profile-view-email');
            userProfileViewRole = document.getElementById('user-profile-view-role');
            userProfileViewSteamLink = document.getElementById('user-profile-view-steam-link');
            userProfileViewRegisteredDate = document.getElementById('user-profile-view-registered-date');
            backToForumFromProfileBtn = document.getElementById('back-to-forum-from-profile'); 
            
            // Recent Members & Chat (Aside)
            recentMembersList = document.getElementById('recent-members-list');
            chatMessagesContainer = document.getElementById('chat-messages');
            chatMessageInput = document.getElementById('chat-message-input');
            sendChatMessageBtn = document.getElementById('send-chat-message-btn');

            // Edit Post Modal
            editPostModal = document.getElementById('edit-post-modal');
            editPostContentInput = document.getElementById('edit-post-content');
            saveEditPostBtn = document.getElementById('save-edit-post-btn');
            cancelEditPostBtn = document.getElementById('cancel-edit-post-btn');

            // Edit Topic Modal
            editTopicModal = document.getElementById('edit-topic-modal');
            editTopicTitleInput = document.getElementById('edit-topic-title');
            editTopicRolePermissionsContainer = document.getElementById('edit-topic-role-permissions-container');
            saveEditTopicBtn = document.getElementById('save-edit-topic-btn');
            cancelEditTopicBtn = document.getElementById('cancel-edit-topic-btn');

            // Registration link container on login page
            registerPromptContainer = document.getElementById('register-prompt-container');
        }

        // --- Event Listeners Setup (DOM Ready) ---
        document.addEventListener('DOMContentLoaded', () => {
            populateDomElementVariables(); // Get all DOM elements first

            // Links to switch between Login and Register views
            const showRegisterViewLink = document.getElementById('show-register-view');
            const showLoginViewLink = document.getElementById('show-login-view');

            if(showRegisterViewLink) {
                showRegisterViewLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (registrationsOpen) {
                        showView('register');
                    } else {
                        showModal("Novos cadastros estÃ£o temporariamente desabilitados.", "info");
                    }
                });
            }
            if(showLoginViewLink) {
                showLoginViewLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    showView('login');
                });
            }
            // My Profile navigation
            if (myProfileNav) {
                myProfileNav.addEventListener('click', (e) => {
                    e.preventDefault();
                    showView('myProfile');
                });
            }

            // Admin Panel Toggle
            if (adminPanelNav && adminControls) {
                adminPanelNav.addEventListener('click', (e) => {
                    e.preventDefault();
                    const isAdminPanelOpen = adminControls.style.display === 'block';
                    adminControls.style.display = isAdminPanelOpen ? 'none' : 'block';
                    adminPanelNav.textContent = isAdminPanelOpen ? 'Painel Admin' : 'Fechar Painel Admin';
                    if (!isAdminPanelOpen && hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                        // Load admin data only when opening and if has permission
                        loadUsersForAdmin(); 
                        loadAdminServerSettings(); 
                        loadRoleColorSettings();
                        loadRolePermissionsSettings();
                        populateCategoryRolePermissionsCheckboxes(); 
                        populateTopicRolePermissionsCheckboxes(topicRolePermissionsContainer); // For create topic modal
                    }
                });
            }


            // Form Submissions & Button Clicks
            if (myProfileSaveBtn) myProfileSaveBtn.addEventListener('click', saveMyProfile);
            if (saveRoleColorsBtn) saveRoleColorsBtn.addEventListener('click', saveRoleColors);
            if (saveForumNameBtn) saveForumNameBtn.addEventListener('click', saveForumName);
            if (saveRegistrationSettingsBtn) saveRegistrationSettingsBtn.addEventListener('click', saveRegistrationSettings);
            if (addCsServerBtn) addCsServerBtn.addEventListener('click', () => openCsServerModal()); // Open with no index for new server
            if (csServerForm) csServerForm.addEventListener('submit', saveCsServer);
            if (cancelCsServerBtn) cancelCsServerBtn.addEventListener('click', () => csServerModal.style.display = 'none');
            if (saveEditPostBtn) saveEditPostBtn.addEventListener('click', saveEditedPost);
            if (cancelEditPostBtn) cancelEditPostBtn.addEventListener('click', () => editPostModal.style.display = 'none');
            if (sendChatMessageBtn) sendChatMessageBtn.addEventListener('click', sendChatMessage);
            if (chatMessageInput) { // Send chat message on Enter key
                chatMessageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { // Shift+Enter for newline
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
            }
            if (backToForumFromProfileBtn) backToForumFromProfileBtn.addEventListener('click', () => showView('forumHome'));
            if (savePermissionsBtn) savePermissionsBtn.addEventListener('click', saveRolePermissions);
            
            // Auth Forms
            const loginForm = document.getElementById('login-form');
            if (loginForm) loginForm.addEventListener('submit', handleLogin);
            
            const registerForm = document.getElementById('register-form');
            if (registerForm) registerForm.addEventListener('submit', handleRegister);

            // Auth Navigation Links
            if (logoutNav) logoutNav.addEventListener('click', handleLogout);
            if (loginNav) loginNav.addEventListener('click', (e) => { e.preventDefault(); showView('login'); });
            if (registerNav) registerNav.addEventListener('click', (e) => {
                e.preventDefault();
                if (registrationsOpen) {
                    showView('register');
                } else {
                    showModal("Novos cadastros estÃ£o temporariamente desabilitados.", "info");
                }
            });

            // Forum Creation Forms
            const createCategoryForm = document.getElementById('create-category-form');
            if (createCategoryForm) createCategoryForm.addEventListener('submit', handleCreateCategory);

            const createTopicFormModal = document.getElementById('create-topic-form-modal'); // Form inside the modal
            if (createTopicFormModal) createTopicFormModal.addEventListener('submit', handleCreateTopic);
            
            const showCreateTopicModalBtn = document.getElementById('show-create-topic-modal'); // Button to open modal
            if(showCreateTopicModalBtn) showCreateTopicModalBtn.addEventListener('click', openCreateTopicModal);

            const cancelCreateTopicBtn = document.getElementById('cancel-create-topic'); // Button in modal
            if(cancelCreateTopicBtn) cancelCreateTopicBtn.addEventListener('click', () => {
                document.getElementById('create-topic-modal').style.display = 'none';
            });

            const createPostForm = document.getElementById('create-post-form'); // Form in topic view
            if (createPostForm) createPostForm.addEventListener('submit', handleCreatePost);
            
            // Forum Navigation (Event Delegation)
            if (breadcrumbs) breadcrumbs.addEventListener('click', handleBreadcrumbNavigation);
            if (categoriesList) categoriesList.addEventListener('click', handleCategoryListClick);
            if (topicsList) topicsList.addEventListener('click', handleTopicListClick);
            if (postsList) postsList.addEventListener('click', handlePostListClick);

            // AI Helper Buttons
            if (generateCategoryDescBtn) generateCategoryDescBtn.addEventListener('click', generateCategoryDescription);
            if (suggestTopicTitleBtn) suggestTopicTitleBtn.addEventListener('click', suggestTopicTitle);

            // Edit Topic Modal Buttons
            if (saveEditTopicBtn) saveEditTopicBtn.addEventListener('click', saveEditedTopic);
            if (cancelEditTopicBtn) cancelEditTopicBtn.addEventListener('click', () => editTopicModal.style.display = 'none');


            // Initialize Authentication
            if (auth) {
                initAuth(); // Handles initial sign-in (e.g., with custom token)
            } else {
                console.warn("Firebase Auth not available at DOMContentLoaded. Login might be impaired.");
                showView('login'); // Default to login if auth isn't ready
            }
        });

        // --- Breadcrumb Navigation ---
        /**
         * Updates the breadcrumb display.
         * @param {Array<object>} path - Array of path objects {name, view, id}.
         */
        function updateBreadcrumbs(path) {
            if (!breadcrumbs) return;
            breadcrumbs.innerHTML = `<a href="#" data-view="forumHome" class="hover:text-blue-400">InÃ­cio</a>`;
            path.forEach(p => {
                breadcrumbs.innerHTML += ` <span class="text-gray-500">/</span> <a href="#" data-view="${p.view}" data-id="${p.id || ''}" class="hover:text-blue-400">${p.name}</a>`;
            });
        }

        /**
         * Handles clicks on breadcrumb links.
         */
        function handleBreadcrumbNavigation(e) {
            if (e.target.tagName === 'A' && e.target.dataset.view) {
                e.preventDefault();
                const view = e.target.dataset.view;
                const id = e.target.dataset.id;
                if (view === 'forumHome') loadCategories();
                else if (view === 'category' && id) loadTopics(id, e.target.textContent);
                // Topic view is handled by loadPosts, breadcrumbs updated there
            }
        }

        // --- Firestore Listener Management ---
        /**
         * Clears all active Firestore listeners.
         * Call this before re-attaching listeners (e.g., on auth state change).
         */
        function clearFirestoreListeners() {
            if (unsubscribeCategories) unsubscribeCategories();
            if (unsubscribeTopics) unsubscribeTopics();
            if (unsubscribePosts) unsubscribePosts();
            if (unsubscribeServerConfig) unsubscribeServerConfig();
            if (unsubscribeRecentMembers) unsubscribeRecentMembers();
            if (unsubscribeChatMessages) unsubscribeChatMessages();
            if (unsubscribeCurrentUserProfile) unsubscribeCurrentUserProfile(); // Clear user's own profile listener
            unsubscribeCategories = null;
            unsubscribeTopics = null;
            unsubscribePosts = null;
            unsubscribeServerConfig = null;
            unsubscribeRecentMembers = null;
            unsubscribeChatMessages = null;
            unsubscribeCurrentUserProfile = null;
            console.log("All Firestore listeners cleared.");
        }


        // --- Authentication State & Profile Handling ---
        if (auth) {
            onAuthStateChanged(auth, async (user) => {
                clearFirestoreListeners(); // Clear old listeners before setting new ones
                showView('loading'); // Show loading indicator during auth change
                if (user) {
                    currentUser = user;
                    currentUserId = user.uid;
                    const userProfileRef = doc(db, `artifacts/${firestorePathAppId}/public/data/userProfiles`, currentUserId);

                    // Listen for real-time updates to the current user's profile
                    unsubscribeCurrentUserProfile = onSnapshot(userProfileRef, async (profileSnap) => {
                        if (!currentUser) return; // If user logs out while listener is active

                        let initialProfileLoad = !userProfileData; // Check if this is the first time loading profile data

                        if (profileSnap.exists()) {
                            const updatedProfileData = profileSnap.data();
                            const oldRole = userProfileData ? userProfileData.role : null; // Store old role for comparison
                            userProfileData = updatedProfileData;
                            isAdmin = (userProfileData.role === 'Admin');
                            
                            console.log("[Profile Listener] Profile data updated:", userProfileData);

                            // Update currentRolePermissions based on the new profile role
                            if (userProfileData.role && serverRolePermissionsConfig[userProfileData.role]) {
                                currentRolePermissions = serverRolePermissionsConfig[userProfileData.role];
                            } else { // Fallback if role not in config (should not happen with defaults)
                                currentRolePermissions = {};
                                if (userProfileData.role) console.warn(`Role "${userProfileData.role}" not found in serverRolePermissionsConfig.`);
                            }
                            console.log("[Profile Listener] Current role permissions set:", currentRolePermissions);


                            // Update UI elements that depend on user profile
                            userDisplay.textContent = `Bem-vindo, ${userProfileData.nickname || userProfileData.displayName || currentUser.email.split('@')[0]}`;
                            currentUserIdDisplay.style.display = isAdmin ? 'inline-block' : 'none';
                            currentUserIdDisplay.textContent = isAdmin ? `User ID: ${currentUserId}` : '';
                            
                            // If 'My Profile' view is active, reload its content
                            if (views.myProfile && views.myProfile.classList.contains('active-view')) {
                                loadMyProfileView(); 
                            }
                            // If it's the initial load or role changed, refresh admin panel elements if visible
                            if (initialProfileLoad || (oldRole && oldRole !== userProfileData.role)) {
                                console.log(`[Profile Listener] Initial profile load (${initialProfileLoad}) or role change (from ${oldRole} to ${userProfileData.role}). Refreshing UI components.`);
                                adminPanelNav.style.display = hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS) ? 'inline-block' : 'none';
                                if (hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS) && adminControls.style.display === 'block') {
                                    // Reload admin panel sections if it's open and permissions allow
                                    loadUsersForAdmin(); 
                                    loadAdminServerSettings(); 
                                    loadRoleColorSettings();
                                    loadRolePermissionsSettings();
                                    populateCategoryRolePermissionsCheckboxes(); 
                                    populateTopicRolePermissionsCheckboxes(topicRolePermissionsContainer);
                                } else if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                                    // Hide admin panel if permissions are lost
                                    adminControls.style.display = 'none'; 
                                    adminPanelNav.textContent = 'Painel Admin';
                                }
                            }


                        } else {
                            // User is authenticated, but no profile document exists. Create one.
                            console.log("[Profile Listener] User profile does not exist. Attempting to create.");
                            try {
                                userProfileData = {
                                    email: currentUser.email,
                                    displayName: currentUser.email ? currentUser.email.split('@')[0] : 'UsuÃ¡rio ' + currentUser.uid.substring(0,5),
                                    nickname: "",
                                    steamProfileUrl: "",
                                    createdAt: Timestamp.now(),
                                    lastSeen: Timestamp.now(),
                                    role: 'Membro' // Default role for new users
                                };
                                await setDoc(userProfileRef, userProfileData);
                                console.log("[Auth/Profile Listener] New user profile created:", JSON.stringify(userProfileData));
                                isAdmin = (userProfileData.role === 'Admin'); // Check admin status after creation
                                initialProfileLoad = true; // Treat as initial load
                            } catch (error) {
                                console.error("[Auth/Profile Listener] Error creating user profile:", error);
                                showModal("Erro ao criar perfil de usuÃ¡rio: " + error.message);
                                // Fallback profile data if creation fails, to prevent app from breaking
                                userProfileData = { role: 'Membro', lastSeen: Timestamp.now() }; 
                                isAdmin = false;
                            }
                        }

                        // After profile is loaded (either existing or newly created)
                        if (initialProfileLoad && userProfileData) { // Only proceed if profile is now available
                            // Update navigation for logged-in user
                            loginNav.style.display = 'none';
                            logoutNav.style.display = 'inline-block';
                            myProfileNav.style.display = 'inline-block';
                            adminPanelNav.style.display = hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS) ? 'inline-block' : 'none';
                            
                            try {
                                await loadServerConfig(); // Load server-wide settings (roles, permissions, etc.)
                                console.log("[Auth State] Server config loaded. Proceeding with other data loads.");
                                // If admin panel was set to be open, load its data
                                if (hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS) && adminControls.style.display === 'block') {
                                    loadUsersForAdmin();
                                    loadAdminServerSettings(); 
                                    loadRoleColorSettings();
                                    loadRolePermissionsSettings();
                                    populateCategoryRolePermissionsCheckboxes();
                                    populateTopicRolePermissionsCheckboxes(topicRolePermissionsContainer);
                                } else if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                                     adminControls.style.display = 'none'; // Ensure it's closed if no perms
                                }
                                // registerNav.style.display is handled by loadServerConfig's onSnapshot
                                loadCategories(); // Load main forum content
                                loadRecentMembers();
                                loadChatMessages();
                                showView('forumHome'); // Show the main forum view
                            } catch (error) {
                                console.error("Failed to load initial server config:", error);
                                showModal("Erro crÃ­tico ao carregar configuraÃ§Ãµes do servidor.", "error");
                                // Fallback for register nav visibility if server config load fails critically
                                if(registerNav) registerNav.style.display = registrationsOpen ? 'inline-block' : 'none'; 
                                if(registerPromptContainer) registerPromptContainer.style.display = registrationsOpen ? 'block' : 'none';
                                showView('forumHome'); // Still try to show forum home
                            }
                        }
                    }, (error) => {
                        console.error("[Profile Listener] Error listening to user profile:", error);
                        showModal("Erro ao carregar dados do perfil. Tente recarregar.", "error");
                        if (auth) signOut(auth); // Log out user on critical profile error
                    });
                    
                    // Update lastSeen timestamp (best effort, don't block UI for this)
                    try {
                        await updateDoc(userProfileRef, { lastSeen: Timestamp.now() });
                    } catch (e) { console.warn("Could not update lastSeen initially:", e.message); }

                } else { // User is logged out
                    if (unsubscribeCurrentUserProfile) { // Clean up profile listener if it was active
                        unsubscribeCurrentUserProfile();
                        unsubscribeCurrentUserProfile = null;
                    }
                    currentUser = null;
                    currentUserId = null; 
                    userProfileData = null;
                    isAdmin = false;
                    currentRolePermissions = {}; // Reset permissions

                    // Update UI for logged-out state
                    userDisplay.textContent = 'VocÃª nÃ£o estÃ¡ logado.';
                    currentUserIdDisplay.style.display = 'none';
                    loginNav.style.display = 'inline-block';
                    logoutNav.style.display = 'none';
                    myProfileNav.style.display = 'none';
                    adminControls.style.display = 'none'; // Hide admin panel
                    adminPanelNav.style.display = 'none';
                    adminPanelNav.textContent = 'Painel Admin'; // Reset admin panel button text
                    
                    try {
                        await loadServerConfig(); // This promise resolves after the first snapshot update,
                                                  // which itself updates registrationsOpen and related UI.
                    } catch (error) {
                        console.error("Error during server config load for logged-out state:", error);
                        // registrationsOpen would have been set to its fallback (now false)
                        // by loadServerConfig's snapshot error handler, and UI updated there.
                        // If loadServerConfig itself throws before even attaching snapshot (less likely),
                        // then registrationsOpen remains its JS default (true).
                        // To be absolutely safe, re-apply based on current registrationsOpen here.
                        if (registerNav) registerNav.style.display = registrationsOpen ? 'inline-block' : 'none'; 
                        if (registerPromptContainer) registerPromptContainer.style.display = registrationsOpen ? 'block' : 'none';
                    }
                    
                    // Clear dynamic content areas
                    if(serverInfoBannerContainer) serverInfoBannerContainer.innerHTML = ''; 
                    if(recentMembersList) recentMembersList.innerHTML = ''; 
                    if(chatMessagesContainer) chatMessagesContainer.innerHTML = ''; 
                    showView('login'); // Show login view, which will also re-check registrationsOpen for the prompt
                }
            });
        } else {
            console.error("Auth service is not available. Application will not function correctly.");
            showModal("ServiÃ§o de autenticaÃ§Ã£o indisponÃ­vel. O aplicativo nÃ£o funcionarÃ¡.");
            showView('login'); // Fallback to login view
        }

        /**
         * Initializes authentication, attempting to sign in with a custom token if provided.
         */
        async function initAuth() {
            if (!auth) {
                console.error("Firebase Auth not initialized. Skipping initAuth.");
                showView('login'); // Default to login if auth isn't ready
                return;
            }
            showView('loading'); // Show loading while attempting auth
            try {
                if (finalInitialAuthToken) { // If a custom token was determined to be used
                    console.log("Attempting sign-in with determined custom token.");
                    await signInWithCustomToken(auth, finalInitialAuthToken);
                    console.log("Successfully signed in with custom token.");
                    // onAuthStateChanged will handle the rest of the UI setup
                } else {
                     console.log("No custom token. Waiting for onAuthStateChanged or user login.");
                     // If no token and no user currently, onAuthStateChanged will show login
                     if (!auth.currentUser) { 
                        // loadServerConfig will be called by onAuthStateChanged when user is null
                        // showView('login') will also be called there.
                     }
                }
            } catch (error) {
                console.error("Authentication initialization error:", error); 
                showModal("Erro na autenticaÃ§Ã£o automÃ¡tica: " + error.message + ". Por favor, faÃ§a login manualmente.", "error");
                showView('login'); // Fallback to manual login
            }
        }

        // --- Auth Actions (Login, Register, Logout) ---
        async function handleLogin(e) {
            e.preventDefault();
            if (!auth) { showModal("ServiÃ§o de autenticaÃ§Ã£o indisponÃ­vel."); return; }
            const email = e.target.email.value;
            const password = e.target.password.value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged will handle UI changes
            } catch (error) {
                console.error("Error signing in:", error);
                showModal("Erro ao fazer login: " + error.message);
            }
        }

        async function handleRegister(e) {
            e.preventDefault();
            if (!registrationsOpen) { // Check if registrations are allowed by admin
                showModal("Novos cadastros estÃ£o temporariamente desabilitados.", "error");
                return;
            }
            if (!auth) { showModal("ServiÃ§o de autenticaÃ§Ã£o indisponÃ­vel."); return; }
            const email = e.target.email.value;
            const password = e.target.password.value;
            const confirmPassword = e.target.confirmPassword.value;

            if (password !== confirmPassword) {
                showModal("As senhas nÃ£o coincidem.");
                return;
            }
            
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                // onAuthStateChanged will create the user profile if it's a new user
                showModal("Registro bem-sucedido! FaÃ§a o login.", "success");
                showView('login'); // Direct user to login after registration
            } catch (error) {
                console.error("Error registering:", error);
                showModal("Erro ao registrar: " + error.message);
            }
        }

        async function handleLogout() {
            if (!auth) { showModal("ServiÃ§o de autenticaÃ§Ã£o indisponÃ­vel."); return; }
            try {
                // Update lastSeen before logging out
                if(currentUser && db && currentUserId) { 
                    const userProfileRef = doc(db, `artifacts/${firestorePathAppId}/public/data/userProfiles`, currentUserId);
                    await updateDoc(userProfileRef, { lastSeen: Timestamp.now() });
                }
                await signOut(auth);
                // onAuthStateChanged will handle UI changes
            } catch (error) {
                console.error("Error signing out:", error);
                showModal("Erro ao fazer logout: " + error.message);
            }
        }
        
        // --- Firestore Collection References ---
        let categoriesCol, topicsCol, postsCol, userProfilesCol, serverConfigDocRef, chatMessagesCol;
        if (db) { // Ensure db is initialized
            categoriesCol = collection(db, `artifacts/${firestorePathAppId}/public/data/categories`);
            topicsCol = collection(db, `artifacts/${firestorePathAppId}/public/data/topics`);
            postsCol = collection(db, `artifacts/${firestorePathAppId}/public/data/posts`);
            userProfilesCol = collection(db, `artifacts/${firestorePathAppId}/public/data/userProfiles`);
            serverConfigDocRef = doc(db, `artifacts/${firestorePathAppId}/public/data/serverConfig`, 'config');
            chatMessagesCol = collection(db, `artifacts/${firestorePathAppId}/public/data/chatMessages`);
        } else {
            console.error("Firestore DB service is not available. Core functionality will be impaired.");
            // Modals or UI indicators should reflect this critical failure.
        }
        
        // --- Clipboard Utility ---
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            textarea.setSelectionRange(0, 99999); // For mobile devices
            try {
                document.execCommand('copy');
                showModal('Comando copiado para a Ã¡rea de transferÃªncia!', 'success');
            } catch (err) {
                showModal('Falha ao copiar. Seu navegador pode nÃ£o suportar esta aÃ§Ã£o.', 'error');
                console.error('Fallback: Oops, unable to copy', err);
            }
            document.body.removeChild(textarea);
        }

        // --- Admin Panel: Server Settings ---
        /**
         * Loads server settings (forum name, registration status, CS servers) into the admin panel.
         */
        async function loadAdminServerSettings() { 
            if (!db || !serverConfigDocRef || !adminForumNameInput || !adminRegistrationsToggle) return;
            try {
                const docSnap = await getDoc(serverConfigDocRef); // Get current settings
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    adminForumNameInput.value = data.forumName || 'Negativa Server - FÃ³rum'; // Default if not set
                    adminRegistrationsToggle.checked = data.registrationsOpen === undefined ? true : data.registrationsOpen; // Default to true
                    renderAdminCsServersList(data.csServers || []); // Render list of CS servers
                } else { // If no config doc, use defaults
                    adminForumNameInput.value = 'Negativa Server - FÃ³rum'; 
                    adminRegistrationsToggle.checked = true; 
                    renderAdminCsServersList([]);
                }
            } catch (error) {
                console.error("Error loading server settings for admin:", error);
            }
        }
        
        /**
         * Saves the forum name from the admin panel.
         */
        async function saveForumName() {
            if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para alterar o nome do fÃ³rum.", "error"); return;
            }
            const newName = adminForumNameInput.value.trim();
            if (!newName) {
                showModal("O nome do fÃ³rum nÃ£o pode estar vazio.", "error"); return;
            }
            try {
                await setDoc(serverConfigDocRef, { forumName: newName }, { merge: true });
                showModal("Nome do fÃ³rum salvo com sucesso!", "success");
                // The onSnapshot listener on serverConfigDocRef will update the public display
            } catch (error) {
                console.error("Error saving forum name:", error);
                showModal("Erro ao salvar nome do fÃ³rum: " + error.message, "error");
            }
        }
        
        /**
         * Saves the registration open/closed status from the admin panel.
         */
        async function saveRegistrationSettings() {
            if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                showModal("VocÃª nÃ£o tem permissÃ£o para alterar as configuraÃ§Ãµes de registro.", "error"); return;
            }
            const newRegistrationsOpen = adminRegistrationsToggle.checked;
            try {
                await setDoc(serverConfigDocRef, { registrationsOpen: newRegistrationsOpen }, { merge: true });
                // The local 'registrationsOpen' variable and UI (nav link, login page link)
                // will be updated by the onSnapshot listener in loadServerConfig.
                showModal(`Cadastros ${newRegistrationsOpen ? 'abertos' : 'fechados'} com sucesso!`, "success");
            } catch (error) {
                console.error("Error saving registration settings:", error);
                showModal("Erro ao salvar configuraÃ§Ãµes de registro: " + error.message, "error");
            }
        }

        
        // --- Admin Panel: CS Server Management ---
        /**
         * Renders the list of CS servers in the admin panel.
         * @param {Array<object>} servers - Array of server objects.
         */
        function renderAdminCsServersList(servers = []) {
            if (!csServersListAdmin) return;
            csServersListAdmin.innerHTML = ''; // Clear previous list
            if (servers.length === 0) {
                csServersListAdmin.innerHTML = '<p class="text-sm text-gray-400">Nenhum servidor CS2 configurado.</p>';
                return;
            }
            servers.forEach((server, index) => {
                const serverDiv = document.createElement('div');
                serverDiv.className = 'bg-gray-700 p-2 rounded-md mb-2 flex justify-between items-center';
                serverDiv.innerHTML = `
                    <div>
                        <p class="text-sm font-medium">${server.displayName || 'Servidor sem nome'}</p>
                        <p class="text-xs text-gray-400">${server.connectCommand || 'Comando nÃ£o definido'}</p>
                    </div>
                    <div>
                        <button class="edit-cs-server-btn text-yellow-400 hover:text-yellow-300 text-xs mr-2" data-index="${index}">Editar</button>
                        <button class="delete-cs-server-btn text-red-500 hover:text-red-400 text-xs" data-index="${index}">Excluir</button>
                    </div>
                `;
                csServersListAdmin.appendChild(serverDiv);
            });

            // Add event listeners for edit/delete buttons
            csServersListAdmin.querySelectorAll('.edit-cs-server-btn').forEach(btn => {
                btn.addEventListener('click', (e) => openCsServerModal(parseInt(e.target.dataset.index)));
            });
            csServersListAdmin.querySelectorAll('.delete-cs-server-btn').forEach(btn => {
                btn.addEventListener('click', (e) => deleteCsServer(parseInt(e.target.dataset.index)));
            });
        }

        /**
         * Opens the CS server configuration modal (for adding or editing).
         * @param {number|null} index - The index of the server to edit, or null to add a new one.
         */
        async function openCsServerModal(index = null) {
            if (!csServerForm || !csServerModal || !csServerIdInput || !csServerNameInput || !csServerConnectInput) return;
            csServerForm.reset(); // Clear form fields
            csServerIdInput.value = index !== null ? index : ''; // Store index if editing
            if (index !== null) { // If editing, load existing server data
                const docSnap = await getDoc(serverConfigDocRef); 
                if (docSnap.exists() && docSnap.data().csServers && docSnap.data().csServers[index]) {
                    const server = docSnap.data().csServers[index];
                    csServerNameInput.value = server.displayName || '';
                    csServerConnectInput.value = server.connectCommand || '';
                }
            }
            csServerModal.style.display = 'flex'; // Show the modal
        }

        /**
         * Saves a CS server (new or edited) to Firestore.
         */
        async function saveCsServer(e) {
            e.preventDefault();
            if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para gerenciar servidores.", "error"); return;
            }
            const serverId = csServerIdInput.value; // Index if editing, empty if new
            const displayName = csServerNameInput.value.trim();
            const connectCommand = csServerConnectInput.value.trim();

            if (!displayName || !connectCommand) {
                showModal("Nome de exibiÃ§Ã£o e comando de conexÃ£o sÃ£o obrigatÃ³rios.", "error"); return;
            }

            try {
                const docSnap = await getDoc(serverConfigDocRef);
                let currentServers = [];
                if (docSnap.exists() && docSnap.data().csServers) {
                    currentServers = [...docSnap.data().csServers]; // Get copy of current servers array
                }

                const newServer = { displayName, connectCommand };
                if (serverId !== '' && currentServers[parseInt(serverId)]) { // Editing existing
                    currentServers[parseInt(serverId)] = newServer;
                } else { // Adding new
                    currentServers.push(newServer);
                }
                
                await setDoc(serverConfigDocRef, { csServers: currentServers }, { merge: true });
                showModal(`Servidor CS2 ${serverId !== '' ? 'atualizado' : 'adicionado'} com sucesso!`, "success");
                if(csServerModal) csServerModal.style.display = 'none'; // Close modal
                // The onSnapshot listener on serverConfigDocRef will re-render the admin list and public banners.
            } catch (error) {
                console.error("Error saving CS server:", error);
                showModal("Erro ao salvar servidor CS2: " + error.message, "error");
            }
        }
        
        /**
         * Deletes a CS server from Firestore.
         * @param {number} index - The index of the server to delete.
         */
        async function deleteCsServer(index) {
             if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para gerenciar servidores.", "error"); return;
            }
            confirmAction("Tem certeza que deseja excluir este servidor CS2?", async () => {
                try {
                    const docSnap = await getDoc(serverConfigDocRef);
                    if (docSnap.exists() && docSnap.data().csServers) {
                        let currentServers = [...docSnap.data().csServers];
                        currentServers.splice(index, 1); // Remove server at index
                        await setDoc(serverConfigDocRef, { csServers: currentServers }, { merge: true });
                        showModal("Servidor CS2 excluÃ­do com sucesso!", "success");
                        // onSnapshot will update the UI.
                    }
                } catch (error) {
                    console.error("Error deleting CS server:", error);
                    showModal("Erro ao excluir servidor CS2: " + error.message, "error");
                }
            });
        }

        /**
         * Renders public CS server banners based on server configuration.
         * @param {Array<object>} serversFromConfig - Array of server objects from Firestore.
         */
        function loadPublicCsServerBanners(serversFromConfig) { 
            if (!serverInfoBannerContainer) return;
            serverInfoBannerContainer.innerHTML = ''; // Clear existing banners
            if (serversFromConfig && serversFromConfig.length > 0) {
                serversFromConfig.forEach(server => {
                    if (server.displayName && server.connectCommand) {
                        const banner = document.createElement('div');
                        banner.className = 'container mx-auto mt-2 bg-gray-700 p-3 text-center rounded-md shadow';
                        banner.innerHTML = `
                            <p class="text-base sm:text-lg text-gray-100">
                                ${server.displayName}: 
                                <a href="steam://connect/${server.connectCommand.replace('connect ', '')}" target="_blank" class="text-yellow-400 hover:text-yellow-300 font-semibold underline">${server.connectCommand.replace('connect ', '')}</a>
                                <button class="copy-cs-command-btn ml-3 bg-blue-500 hover:bg-blue-600 text-white text-xs py-1 px-3 rounded-md transition duration-150" data-command="${server.connectCommand}">Copiar Comando</button>
                            </p>
                        `;
                        serverInfoBannerContainer.appendChild(banner);
                    }
                });
                // Add event listeners for copy buttons
                serverInfoBannerContainer.querySelectorAll('.copy-cs-command-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => copyToClipboard(e.target.dataset.command));
                });
            }
        }


        // --- Admin Panel: User Management ---
        /**
         * Loads and displays the list of users in the admin panel.
         */
        async function loadUsersForAdmin() {
            if (!db || !userProfilesCol || !hasPermission(PERMISSIONS.MANAGE_USERS) || !adminUserList) return;
            adminUserList.innerHTML = '<div class="loading-spinner"></div><p class="text-gray-400 text-center">Carregando usuÃ¡rios...</p>';
            try {
                const snapshot = await getDocs(query(userProfilesCol)); // Get all user profiles
                if (snapshot.empty) {
                    adminUserList.innerHTML = '<p class="text-gray-400 p-4 text-center">Nenhum usuÃ¡rio registrado encontrado.</p>';
                    return;
                }
                let usersHtml = '';
                // Sort users by email for consistent display
                const userDocs = snapshot.docs.sort((a,b) => (a.data().email || '').localeCompare(b.data().email || ''));

                userDocs.forEach(userDoc => {
                    const userId = userDoc.id;
                    const profile = userDoc.data();
                    // Prevent admin from changing their own role if they are the one editing
                    const isCurrentUserAdminEditingSelf = profile.role === 'Admin' && currentUserId === userId;

                    usersHtml += `
                        <div class="bg-gray-700 p-3 rounded-md flex flex-col sm:flex-row justify-between items-start sm:items-center">
                            <div class="mb-2 sm:mb-0">
                                <p class="text-sm font-medium">${profile.nickname || profile.displayName || profile.email || 'N/A'}</p>
                                <p class="text-xs text-gray-400">Email: ${profile.email || 'N/A'} | Cargo: <span id="role-display-${userId}">${profile.role || 'Membro'}</span></p>
                                <p class="text-xs text-gray-500">Registrado em: ${formatTimestamp(profile.createdAt)} | Visto por Ãºltimo: ${formatTimestamp(profile.lastSeen)}</p>
                                <input type="text" id="nickname-edit-${userId}" value="${profile.nickname || ''}" placeholder="Nickname" class="mt-1 p-1 text-xs bg-gray-600 border border-gray-500 rounded-md text-gray-100 w-full sm:w-auto">
                                <input type="url" id="steamurl-edit-${userId}" value="${profile.steamProfileUrl || ''}" placeholder="URL Perfil Steam" class="mt-1 p-1 text-xs bg-gray-600 border border-gray-500 rounded-md text-gray-100 w-full sm:w-auto">
                            </div>
                            <div class="flex items-center mt-2 sm:mt-0">
                                <select id="select-role-${userId}" class="bg-gray-600 border border-gray-500 text-gray-100 text-xs rounded-md p-1 mr-2 w-full sm:w-auto" ${isCurrentUserAdminEditingSelf ? 'disabled' : ''}>
                                    ${defaultRoles.map(role => `<option value="${role}" ${profile.role === role ? 'selected' : ''}>${role}</option>`).join('')}
                                </select>
                                <button data-userid="${userId}" class="save-user-details-btn bg-blue-500 hover:bg-blue-600 text-white text-xs py-1 px-2 rounded" ${isCurrentUserAdminEditingSelf ? 'disabled' : ''}>Salvar</button>
                            </div>
                        </div>
                    `;
                });
                adminUserList.innerHTML = usersHtml;

                // Add event listeners to "Save" buttons for each user
                document.querySelectorAll('.save-user-details-btn').forEach(button => {
                    if (button.disabled) return; // Skip disabled buttons (admin editing self)
                    button.addEventListener('click', async (e) => {
                        const userIdToUpdate = e.target.dataset.userid;
                        const newRole = document.getElementById(`select-role-${userIdToUpdate}`).value;
                        const newNickname = document.getElementById(`nickname-edit-${userIdToUpdate}`).value.trim();
                        const newSteamUrl = document.getElementById(`steamurl-edit-${userIdToUpdate}`).value.trim();
                        await updateUserDetailsByAdmin(userIdToUpdate, newRole, newNickname, newSteamUrl);
                    });
                });

            } catch (error) {
                console.error("Error loading users for admin:", error);
                adminUserList.innerHTML = '<p class="text-red-400 p-4 text-center">Erro ao carregar usuÃ¡rios.</p>';
                showModal("Erro ao carregar usuÃ¡rios: " + error.message, "error");
            }
        }
        
        /**
         * Updates a user's details (role, nickname, Steam URL) by an admin.
         */
        async function updateUserDetailsByAdmin(userId, newRole, newNickname, newSteamUrl) {
            if (!hasPermission(PERMISSIONS.MANAGE_USERS)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para gerenciar usuÃ¡rios.", "error"); return;
            }
            const userToUpdateRef = doc(userProfilesCol, userId);
            try {
                // Prevent an admin from accidentally removing their own 'Admin' role
                if (userId === currentUserId && newRole !== 'Admin' && isAdmin) { 
                     showModal("Administradores nÃ£o podem remover seu prÃ³prio cargo de 'Admin'.", "error");
                     document.getElementById(`select-role-${userId}`).value = 'Admin'; // Revert dropdown
                     return;
                }
                await updateDoc(userToUpdateRef, { 
                    role: newRole,
                    nickname: newNickname,
                    steamProfileUrl: newSteamUrl
                });
                showModal(`Detalhes do usuÃ¡rio atualizados.`, "success");
                // Update the displayed role in the admin list immediately
                const roleDisplaySpan = document.getElementById(`role-display-${userId}`);
                if (roleDisplaySpan) roleDisplaySpan.textContent = newRole; 
                // The user's own profile listener (if they are the one being edited) will pick up changes.
            } catch (error) {
                console.error("Error updating user details by admin:", error);
                showModal("Erro ao atualizar detalhes do usuÃ¡rio: " + error.message, "error");
            }
        }

        // --- Admin Panel: Category & Topic Role Permissions UI ---
        /**
         * Populates checkboxes for assigning roles that can view a new category (in admin panel).
         */
        function populateCategoryRolePermissionsCheckboxes() {
            if (!categoryRolePermissionsAdminContainer) return;
            categoryRolePermissionsAdminContainer.innerHTML = ''; 
            const listContainer = document.createElement('div'); 
            listContainer.className = "flex flex-col space-y-1"; 

            defaultRoles.forEach(role => {
                if (role === 'Admin') return; 
                const checkboxId = `category-perm-role-${role}`;
                const label = document.createElement('label');
                label.className = 'flex items-center space-x-2 text-sm text-gray-300';
                label.innerHTML = `
                    <input type="checkbox" id="${checkboxId}" name="categoryAllowedRoles" value="${role}" 
                           class="form-checkbox h-4 w-4 text-blue-500 bg-gray-600 border-gray-500 rounded focus:ring-blue-400">
                    <span>${role}</span>
                `;
                listContainer.appendChild(label); 
            });
            categoryRolePermissionsAdminContainer.appendChild(listContainer); 
        }

        /**
         * Populates checkboxes for assigning roles that can view a topic.
         * Used in "Create Topic" modal and "Edit Topic" modal.
         * @param {HTMLElement} container - The DOM element to populate with checkboxes.
         * @param {Array<string>} currentAllowedRoles - Array of roles currently allowed (for pre-checking).
         */
        function populateTopicRolePermissionsCheckboxes(container, currentAllowedRoles = []) {
            if (!container) return;
            container.innerHTML = ''; 
            const listContainer = document.createElement('div'); 
            listContainer.className = "flex flex-col space-y-1"; 

            defaultRoles.forEach(role => {
                if (role === 'Admin') return; 
                const checkboxId = `topic-perm-role-${role}-${container.id}`; 
                const isChecked = currentAllowedRoles.includes(role);
                const label = document.createElement('label');
                label.className = 'flex items-center space-x-2 text-sm text-gray-300';
                label.innerHTML = `
                    <input type="checkbox" id="${checkboxId}" name="topicAllowedRoles" value="${role}" 
                           class="form-checkbox h-4 w-4 text-blue-500 bg-gray-600 border-gray-500 rounded focus:ring-blue-400"
                           ${isChecked ? 'checked' : ''}>
                    <span>${role}</span>
                `;
                listContainer.appendChild(label); 
            });
            container.appendChild(listContainer); 
        }


        // --- Forum Content Creation (Categories, Topics, Posts) ---
        /**
         * Handles the creation of a new category.
         */
        async function handleCreateCategory(e) {
            e.preventDefault();
             if (!hasPermission(PERMISSIONS.MANAGE_CATEGORIES)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para criar categorias.", "error"); return;
            }
            const name = categoryNameInput.value.trim(); 
            const description = categoryDescriptionInput.value.trim(); 
            if (!name) {
                showModal("O nome da categoria Ã© obrigatÃ³rio.", "error"); return;
            }

            const selectedRoles = []; // Roles allowed to view this category
            const checkboxes = document.querySelectorAll('#category-role-permissions-admin-container input[name="categoryAllowedRoles"]:checked');
            checkboxes.forEach(checkbox => selectedRoles.push(checkbox.value));

            try {
                const userDisplayNameForActivity = userProfileData?.nickname || userProfileData?.displayName || (currentUser?.email?.split('@')[0] || "Sistema");
                await addDoc(categoriesCol, {
                    name,
                    description,
                    createdBy: currentUserId,
                    createdAt: Timestamp.now(),
                    topicCount: 0,
                    postCount: 0,
                    lastActivity: Timestamp.now(), // Initial activity is creation
                    lastActivityDetails: { // Details about the last activity
                        topicId: null, // No topic yet
                        topicTitle: "Nenhum tÃ³pico ainda",
                        userId: currentUserId, 
                        userDisplayName: userDisplayNameForActivity,
                        timestamp: Timestamp.now()
                    },
                    allowedRoles: selectedRoles // Store empty array if public, or roles if restricted
                });
                showModal("Categoria criada com sucesso!", "success");
                e.target.reset(); // Clear form
                // Clear role permission checkboxes for the next category
                document.querySelectorAll('#category-role-permissions-admin-container input[name="categoryAllowedRoles"]').forEach(cb => cb.checked = false);
                // The categories list will update via its onSnapshot listener.
            } catch (error) {
                console.error("Error creating category:", error);
                showModal("Erro ao criar categoria: " + error.message);
            }
        }

        /**
         * Loads and displays categories on the forum home page.
         */
        async function loadCategories() {
            if (!db || !categoriesCol || !userProfilesCol || !categoriesList) { 
                if(categoriesList) categoriesList.innerHTML = '<div class="p-4 text-center text-red-400">Erro: ServiÃ§o de banco de dados indisponÃ­vel.</div>';
                showView('forumHome'); 
                return; 
            }
            if (!currentUser) { // User must be logged in to see categories (even public ones, due to profile needs)
                console.log("loadCategories called without current user, redirecting to login.");
                showView('login'); return;
            }
            showView('loading'); // Show loading indicator
            updateBreadcrumbs([]); // Reset breadcrumbs to "Home"
            
            categoriesList.innerHTML = '<div class="loading-spinner"></div><p class="text-gray-400 text-center">Carregando categorias...</p>';
            const q = query(categoriesCol); // Get all categories (will be sorted client-side by last activity)
            
            if (unsubscribeCategories) unsubscribeCategories(); // Clear previous listener
            unsubscribeCategories = onSnapshot(q, async (snapshot) => {
                if (!currentUser) return; // If user logs out while listener is active
                
                const categoriesToShow = [];
                if (snapshot.empty) {
                    categoriesList.innerHTML = '<div class="p-6 text-center text-gray-400 bg-gray-800 rounded-lg shadow">Nenhuma categoria encontrada. Que tal o administrador criar a primeira?</div>';
                    showView('forumHome');
                    return;
                }

                // Filter categories based on user's role and category's allowedRoles
                snapshot.docs.forEach(doc => {
                    const category = doc.data();
                    category.id = doc.id; // Add document ID to the category object
                    if (isAdmin) { // Admins see all categories
                        categoriesToShow.push(category);
                    } else {
                        const allowed = category.allowedRoles;
                        // If no roles specified (public) or user's role is in allowedRoles
                        if (!allowed || allowed.length === 0 || (userProfileData && allowed.includes(userProfileData.role))) {
                            categoriesToShow.push(category);
                        }
                    }
                });

                if (categoriesToShow.length === 0 && !isAdmin) { // No categories visible to this non-admin user
                     categoriesList.innerHTML = '<div class="p-6 text-center text-gray-400 bg-gray-800 rounded-lg shadow">Nenhuma categoria disponÃ­vel para seu cargo.</div>';
                     showView('forumHome');
                     return;
                }


                // Fetch user profiles for 'lastActivityDetails.userDisplayName' and 'createdBy' for display names
                const userIdsForLastActivity = new Set();
                categoriesToShow.forEach(cat => {
                    const activityUserId = cat.lastActivityDetails?.userId;
                    if (activityUserId) userIdsForLastActivity.add(activityUserId);
                    const createdById = cat.createdBy; // Also fetch creator for initial display if no activity
                    if (createdById) userIdsForLastActivity.add(createdById);
                });

                const activityUserProfiles = {}; // Cache for fetched profiles
                if (userIdsForLastActivity.size > 0) {
                    const profilePromises = Array.from(userIdsForLastActivity).map(uid => getDoc(doc(userProfilesCol, uid)));
                    try {
                        const profileSnaps = await Promise.all(profilePromises);
                        profileSnaps.forEach(snap => {
                            if (snap.exists()) {
                                const data = snap.data();
                                // Prefer nickname, then displayName, then part of email
                                activityUserProfiles[snap.id] = data.nickname || data.displayName || data.email?.split('@')[0] || 'Desconhecido';
                            } else {
                                activityUserProfiles[snap.id] = 'UsuÃ¡rio Deletado';
                            }
                        });
                    } catch (err) {
                        console.error("Error fetching user profiles for category last activity:", err);
                        // UI will show default "Desconhecido" or stored display name if profiles fail to load
                    }
                }

                // Sort categories by last activity timestamp (descending)
                const sortedCategories = categoriesToShow.sort((a, b) => {
                    const timeA = a.lastActivityDetails?.timestamp?.seconds || a.createdAt?.seconds || 0;
                    const timeB = b.lastActivityDetails?.timestamp?.seconds || b.createdAt?.seconds || 0;
                    return timeB - timeA; // Most recent first
                }); 

                let categoriesHtml = '';
                sortedCategories.forEach(category => {
                    const lastActivity = category.lastActivityDetails;
                    let lastActivityHtml = 'Nenhuma atividade recente.';
                    if (lastActivity && lastActivity.topicId && lastActivity.topicTitle !== "Nenhum tÃ³pico ainda") {
                        const userName = activityUserProfiles[lastActivity.userId] || lastActivity.userDisplayName || 'Desconhecido';
                        lastActivityHtml = `
                            Ãltimo: <a href="#" class="text-blue-400 hover:underline" data-topic-id-link="${lastActivity.topicId}" data-topic-title-link="${lastActivity.topicTitle}" data-category-id-for-topic="${category.id}" data-category-name-for-topic="${category.name}">${lastActivity.topicTitle}</a><br>
                            por ${userName}, ${formatTimestamp(lastActivity.timestamp)}
                        `;
                    } else if (lastActivity && lastActivity.userDisplayName) { // Fallback if no topic but creation activity
                         lastActivityHtml = `Criada por ${activityUserProfiles[lastActivity.userId] || lastActivity.userDisplayName}, ${formatTimestamp(lastActivity.timestamp)}`;
                    }


                    categoriesHtml += `
                        <div class="bg-gray-800 p-4 rounded-lg shadow hover:shadow-xl transition-shadow duration-200">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="text-xl font-semibold text-blue-400 hover:text-blue-300 cursor-pointer category-link" data-id="${category.id}" data-name="${category.name}">${category.name}</h3>
                                    <p class="text-gray-400 text-sm mt-1">${category.description || 'Sem descriÃ§Ã£o.'}</p>
                                    ${ (category.allowedRoles && category.allowedRoles.length > 0) ? `<p class="text-xs text-yellow-400 mt-1">Privado para: ${category.allowedRoles.join(', ')}</p>` : '<p class="text-xs text-green-400 mt-1">PÃºblico</p>'}
                                </div>
                                ${hasPermission(PERMISSIONS.MANAGE_CATEGORIES) ? `<button class="delete-category-btn text-red-500 hover:text-red-400 text-xs ml-2" data-id="${category.id}" data-name="${category.name}">Excluir</button>` : ''}
                            </div>
                            <div class="grid grid-cols-3 gap-2 text-xs text-gray-500 mt-3 pt-3 border-t border-gray-700">
                                <div>TÃ³picos: ${category.topicCount || 0}</div>
                                <div>Posts: ${category.postCount || 0}</div>
                                <div class="col-span-3 sm:col-span-1 text-left sm:text-right">${lastActivityHtml}</div>
                            </div>
                        </div>
                    `;
                });
                categoriesList.innerHTML = categoriesHtml;
                // Add event listeners for links within the generated HTML (e.g., last activity topic link)
                categoriesList.querySelectorAll('a[data-topic-id-link]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation(); // Prevent category link click if clicking on last activity
                        const topicId = e.target.dataset.topicIdLink;
                        const topicTitle = e.target.dataset.topicTitleLink;
                        currentCategoryId = e.target.dataset.categoryIdForTopic; // Set context for breadcrumbs
                        currentCategoryName = e.target.dataset.categoryNameForTopic;
                        loadPosts(topicId, topicTitle); // Navigate to topic view
                    });
                });

                showView('forumHome'); // Show the view after content is ready
            }, (error) => {
                console.error("Error loading categories:", error);
                 if (currentUser && categoriesList) { // Only show error in UI if user is logged in
                    categoriesList.innerHTML = '<div class="p-6 text-center text-red-400 bg-gray-800 rounded-lg shadow">Erro ao carregar categorias. Verifique as permissÃµes do Firestore e a conexÃ£o.</div>';
                    showModal("Erro ao carregar categorias: " + error.message + ". Verifique as permissÃµes do Firestore.");
                 }
                showView('forumHome'); // Still show home view, but with error message
            });
        }
        
        /**
         * Handles clicks within the categories list (e.g., to delete a category or navigate to it).
         */
        function handleCategoryListClick(e) {
            if (e.target.classList.contains('delete-category-btn')) { // Clicked delete button
                e.stopPropagation(); // Prevent navigation if clicking delete
                const categoryId = e.target.dataset.id;
                const categoryName = e.target.dataset.name;
                confirmAction(`Tem certeza que deseja excluir a categoria "${categoryName}" e todos os seus tÃ³picos e posts? Esta aÃ§Ã£o Ã© irreversÃ­vel.`, async () => {
                    if (!db) { showModal("ServiÃ§o de banco de dados indisponÃ­vel."); return; }
                    await deleteCategory(categoryId);
                });
            } else { // Clicked on category link/area
                const categoryLink = e.target.closest('.category-link');
                if (categoryLink && categoryLink.dataset.id) { 
                     loadTopics(categoryLink.dataset.id, categoryLink.dataset.name);
                }
            }
        }

        /**
         * Deletes a category and all its associated topics and posts.
         * @param {string} categoryId - The ID of the category to delete.
         */
        async function deleteCategory(categoryId) {
            if (!hasPermission(PERMISSIONS.MANAGE_CATEGORIES)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para deletar categorias.", "error"); return;
            }
            showModal("Excluindo categoria... Isso pode levar um momento.", "info"); // Inform user
            try {
                // 1. Delete all posts in all topics of this category
                const topicsInCatQuery = query(topicsCol, where("categoryId", "==", categoryId));
                const topicsInCatSnapshot = await getDocs(topicsInCatQuery);
                for (const topicDoc of topicsInCatSnapshot.docs) {
                    const postsInTopicQuery = query(postsCol, where("topicId", "==", topicDoc.id));
                    const postsInTopicSnapshot = await getDocs(postsInTopicQuery);
                    for (const postDoc of postsInTopicSnapshot.docs) {
                        await deleteDoc(doc(postsCol, postDoc.id));
                    }
                    // 2. Delete the topic itself
                    await deleteDoc(doc(topicsCol, topicDoc.id));
                }
                // 3. Delete the category
                await deleteDoc(doc(categoriesCol, categoryId));
                showModal("Categoria excluÃ­da com sucesso!", "success");
                // The categories list will update via its onSnapshot listener.
            } catch (error) {
                console.error("Error deleting category:", error);
                showModal("Erro ao excluir categoria: " + error.message, "error");
            }
        }

        // --- Topic Management ---
        let currentCategoryName = ''; // Name of the current category being viewed
        let currentCategoryId = null; // ID of the current category
        let currentCategoryAllowedRoles = []; // Roles allowed for the current category (for topic creation defaults)

        /**
         * Opens the "Create New Topic" modal.
         */
        function openCreateTopicModal() {
            if (!hasPermission(PERMISSIONS.CREATE_TOPIC)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para criar tÃ³picos.", "error"); return;
            }
            if (!currentCategoryId) { // Must be in a category to create a topic
                showModal("Selecione uma categoria antes de criar um tÃ³pico.", "error"); return;
            }
            // Reset form fields
            if (newTopicTitleInput) newTopicTitleInput.value = ''; 
            if (newTopicContentInput) newTopicContentInput.value = ''; 
            if (newTopicCommandInput) newTopicCommandInput.value = '';
            // Populate role permission checkboxes, defaulting to category's roles
            populateTopicRolePermissionsCheckboxes(topicRolePermissionsContainer, currentCategoryAllowedRoles); 
            
            const createTopicModal = document.getElementById('create-topic-modal');
            if(createTopicModal) createTopicModal.style.display = 'flex';
        }
        
        /**
         * Handles the creation of a new topic and its first post.
         */
        async function handleCreateTopic(e) {
            e.preventDefault();
            if (!hasPermission(PERMISSIONS.CREATE_TOPIC)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para criar tÃ³picos.", "error"); return;
            }
            if (!currentUser || !currentCategoryId) {
                showModal("VocÃª precisa estar logado e em uma categoria para criar um tÃ³pico.");
                return;
            }
            const title = newTopicTitleInput.value.trim(); 
            const content = newTopicContentInput.value.trim(); 
            // ValidaÃ§Ã£o dos comandos
            for (const cmd of topicCommands) {
                if (containsProhibitedCode(cmd.nome) || containsProhibitedCode(cmd.comando)) {
                    showModal("Um dos comandos contÃ©m cÃ³digo proibido (HTML/JavaScript). Por favor, envie apenas texto.", "error");
                    return;
                }
            }
            if (!title || !content) {
                showModal("TÃ­tulo e conteÃºdo do primeiro post sÃ£o obrigatÃ³rios.");
                return;
            }
            if (containsProhibitedCode(title) || containsProhibitedCode(content)) {
                showModal("O tÃ­tulo ou conteÃºdo contÃ©m cÃ³digo proibido (HTML/JavaScript). Por favor, envie apenas texto.", "error");
                return;
            }

            const selectedTopicRoles = []; // Roles allowed to view this specific topic
            const topicRoleCheckboxes = document.querySelectorAll('#topic-role-permissions-container input[name="topicAllowedRoles"]:checked');
            topicRoleCheckboxes.forEach(checkbox => selectedTopicRoles.push(checkbox.value));

            const now = Timestamp.now();
            const userDisplayName = userProfileData?.nickname || userProfileData?.displayName || currentUser.email.split('@')[0];
            try {
                // 1. Create the topic document
                const topicRef = await addDoc(topicsCol, {
                    categoryId: currentCategoryId,
                    title,
                    createdBy: currentUserId,
                    userDisplayName: userDisplayName, // Store initial display name
                    createdAt: now,
                    replyCount: 0, // Starts with 0 replies (first post is not a reply)
                    postCount: 1, // Starts with 1 post (the initial post)
                    lastReplyAt: now, // Timestamp of the last activity (initial post)
                    lastReplyBy: currentUserId,
                    lastReplyByDisplayName: userDisplayName,
                    viewCount: 0,
                    allowedRoles: selectedTopicRoles.length > 0 ? selectedTopicRoles : [] // Empty means inherit/public
                });

                // 2. Create the first post para este tÃ³pico
                await addDoc(postsCol, {
                    topicId: topicRef.id,
                    userId: currentUserId,
                    userDisplayName: userDisplayName,
                    content,
                    createdAt: now,
                    topicCommands: topicCommands.filter(cmd => cmd.nome && cmd.comando) // Salva sÃ³ comandos preenchidos
                });
                
                // 3. Update category metadata (topic count, post count, last activity)
                const categoryRef = doc(categoriesCol, currentCategoryId);
                await updateDoc(categoryRef, {
                    topicCount: increment(1),
                    postCount: increment(1), // Also increment category's total post count
                    lastActivity: now, 
                    lastActivityDetails: {
                        topicId: topicRef.id,
                        topicTitle: title,
                        userId: currentUserId,
                        userDisplayName: userDisplayName, 
                        timestamp: now
                    }
                });
                
                showModal("TÃ³pico criado com sucesso!", "success");
                if (document.getElementById('create-topic-form-modal')) document.getElementById('create-topic-form-modal').reset(); 
                if (document.getElementById('create-topic-modal')) document.getElementById('create-topic-modal').style.display = 'none';
                // The topics list will update via its onSnapshot listener.
            } catch (error) {
                console.error("Error creating topic:", error);
                showModal("Erro ao criar tÃ³pico: " + error.message);
            }
        }


        /**
         * Loads and displays topics for a given category.
         * @param {string} categoryId - The ID of the category.
         * @param {string} categoryName - The name of the category (for display).
         */
        async function loadTopics(categoryId, categoryName) {
            if (!db || !topicsCol || !userProfilesCol || !topicsList || !categoryTitle) { 
                if(topicsList) topicsList.innerHTML = '<div class="p-4 text-center text-red-400">Erro: ServiÃ§o de banco de dados indisponÃ­vel.</div>';
                showView('category');
                return; 
            }
            if (!currentUser || !userProfileData) { // Ensure userProfileData is available for role checks
                 console.log("loadTopics: currentUser or userProfileData not available. Redirecting to login.");
                 showView('login'); return; 
            }

            showView('loading');
            currentCategoryId = categoryId; // Set global context
            currentCategoryName = categoryName;
            categoryTitle.textContent = categoryName; // Display category name in view
            updateBreadcrumbs([{name: categoryName, view: 'category', id: categoryId}]);

            // Fetch category details to get its allowedRoles (for topic creation defaults and permission checks)
            const categoryRef = doc(categoriesCol, categoryId);
            const categorySnap = await getDoc(categoryRef);
            if (!categorySnap.exists()) {
                showModal("Categoria nÃ£o encontrada.", "error");
                showView('forumHome'); // Go back if category doesn't exist
                return;
            }
            const categoryData = categorySnap.data();
            currentCategoryAllowedRoles = categoryData.allowedRoles || []; // Store for "Create Topic" modal

            // Check if user can view this category (redundant if navigated from categories list, but good for direct links)
            if (!isAdmin && currentCategoryAllowedRoles.length > 0 && !currentCategoryAllowedRoles.includes(userProfileData.role)) {
                topicsList.innerHTML = '<div class="p-6 text-center text-gray-400 bg-gray-800 rounded-lg shadow">VocÃª nÃ£o tem permissÃ£o para ver os tÃ³picos desta categoria.</div>';
                showView('category');
                return;
            }
            
            topicsList.innerHTML = '<div class="loading-spinner"></div><p class="text-gray-400 text-center">Carregando tÃ³picos...</p>';
            const q = query(topicsCol, where("categoryId", "==", categoryId)); // Get topics for this category
            
            if (unsubscribeTopics) unsubscribeTopics(); // Clear previous listener
            unsubscribeTopics = onSnapshot(q, async (snapshot) => {
                if (!currentUser || !userProfileData) return; // Check again inside snapshot for safety
                
                const topicsToShow = [];
                snapshot.docs.forEach(doc => {
                    const topic = doc.data();
                    topic.id = doc.id;
                    let canViewThisTopic = false;
                    if (isAdmin) { // Admins see all
                        canViewThisTopic = true;
                    } else {
                        const topicRoles = topic.allowedRoles;
                        if (topicRoles && topicRoles.length > 0) { // Topic has its own specific roles
                            if (topicRoles.includes(userProfileData.role)) {
                                canViewThisTopic = true;
                            }
                        } else { // Topic inherits from category (which we've already checked access for)
                            canViewThisTopic = true; 
                        }
                    }
                    if(canViewThisTopic) topicsToShow.push(topic);
                });

                if (topicsToShow.length === 0) {
                    topicsList.innerHTML = '<div class="p-6 text-center text-gray-400 bg-gray-800 rounded-lg shadow">Nenhum tÃ³pico encontrado (ou visÃ­vel para vocÃª) nesta categoria.</div>';
                    showView('category');
                    return;
                }


                // Fetch user profiles for createdBy and lastReplyBy display names
                const userIds = new Set();
                topicsToShow.forEach(topic => {
                    if(topic.createdBy) userIds.add(topic.createdBy);
                    if(topic.lastReplyBy) userIds.add(topic.lastReplyBy);
                });

                const profiles = {}; // Cache for fetched profiles
                if (userIds.size > 0) {
                    const profilePromises = Array.from(userIds).map(uid => getDoc(doc(userProfilesCol, uid)));
                     try {
                        const profileSnaps = await Promise.all(profilePromises);
                        profileSnaps.forEach(snap => {
                            if (snap.exists()) {
                                const data = snap.data();
                                profiles[snap.id] = {
                                    displayName: data.nickname || data.displayName || data.email?.split('@')[0] || 'Desconhecido',
                                    role: data.role || 'Membro' // Also get role for potential display later
                                };
                            } else {
                                profiles[snap.id] = { displayName: 'UsuÃ¡rio Deletado', role: 'Membro' };
                            }
                        });
                    } catch (err) { console.error("Error fetching user profiles for topics:", err); }
                }
                
                // Sort topics by last reply time (descending)
                const sortedDocs = topicsToShow.sort((a,b) => { 
                    const timeA = a.lastReplyAt?.seconds || a.createdAt?.seconds || 0;
                    const timeB = b.lastReplyAt?.seconds || b.createdAt?.seconds || 0;
                    return timeB - timeA; // Most recent first
                });

                let topicsHtml = '';
                sortedDocs.forEach(topic => {
                    const createdByDisplayName = profiles[topic.createdBy]?.displayName || topic.userDisplayName || 'Desconhecido';
                    const lastReplyByDisplayName = profiles[topic.lastReplyBy]?.displayName || topic.lastReplyByDisplayName || 'N/A';
                    
                    // Actions: Edit (pencil icon), Delete
                    let topicActionsHtml = '';
                    // Edit: Topic creator OR user with MANAGE_CATEGORIES (as a proxy for "manage any topic")
                    if (currentUser.uid === topic.createdBy || hasPermission(PERMISSIONS.MANAGE_CATEGORIES) ) {
                         topicActionsHtml += `<svg class="edit-topic-btn-icon w-4 h-4 inline-block" data-topic-id="${topic.id}" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>`;
                    }
                    // Delete: User with DELETE_ANY_TOPIC OR (user with DELETE_OWN_TOPIC AND is creator)
                    if (hasPermission(PERMISSIONS.DELETE_ANY_TOPIC) || (hasPermission(PERMISSIONS.DELETE_OWN_TOPIC) && currentUser.uid === topic.createdBy)) {
                        topicActionsHtml += `<button class="delete-topic-btn text-red-500 hover:text-red-400 text-xs ml-2 self-start p-1" data-id="${topic.id}" data-title="${topic.title}">Excluir</button>`;
                    }
                    // Display privacy info (public, private inherited, or private specific to topic)
                    const topicPrivacyInfo = (topic.allowedRoles && topic.allowedRoles.length > 0) 
                        ? `<p class="text-xs text-yellow-400 mt-1">Privado para: ${topic.allowedRoles.join(', ')}</p>` 
                        : (currentCategoryAllowedRoles.length > 0 ? `<p class="text-xs text-yellow-400 mt-1">Privado (herdado da categoria)</p>` : `<p class="text-xs text-green-400 mt-1">PÃºblico</p>`);


                    topicsHtml += `
                        <div class="bg-gray-800 p-4 rounded-lg shadow flex justify-between items-start hover:bg-gray-700 transition-colors duration-150 topic-link-container">
                            <div class="flex-grow">
                                <h4 class="text-lg font-medium text-blue-400 hover:text-blue-300 cursor-pointer topic-title-link" data-id="${topic.id}" data-title="${topic.title}">
                                    ${topic.title}
                                </h4>
                                ${topicPrivacyInfo}
                                <p class="text-xs text-gray-500 mt-1">
                                    Criado por: <a href="#" class="text-blue-300 hover:underline user-profile-link" data-userid="${topic.createdBy}">${createdByDisplayName}</a> (${formatTimestamp(topic.createdAt)})
                                </p>
                                <p class="text-xs text-gray-500">VisualizaÃ§Ãµes: ${topic.viewCount || 0} | Respostas: ${topic.replyCount || 0}</p>
                            </div>
                            <div class="text-right text-sm flex-shrink-0 ml-4 w-48">
                                <p class="truncate">Ãltima por: <a href="#" class="text-blue-300 hover:underline user-profile-link" data-userid="${topic.lastReplyBy}">${lastReplyByDisplayName}</a></p>
                                <p class="text-xs text-gray-500">${formatTimestamp(topic.lastReplyAt)}</p>
                            </div>
                            <div class="flex flex-col items-end space-y-1 ml-2">
                                ${topicActionsHtml}
                            </div>
                        </div>
                    `;
                });
                topicsList.innerHTML = topicsHtml;
                addProfileLinkListeners(topicsList); // Attach listeners for user profile links
                // Add event listeners for edit topic buttons (pencil icons)
                topicsList.querySelectorAll('.edit-topic-btn-icon').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Prevent topic navigation when clicking icon
                        const topicId = e.target.closest('.edit-topic-btn-icon').dataset.topicId;
                        const topicRef = doc(topicsCol, topicId);
                        const topicSnap = await getDoc(topicRef);
                        if (topicSnap.exists()) {
                            openEditTopicModal(topicId, topicSnap.data()); // Open modal with topic data
                        } else {
                            showModal("TÃ³pico nÃ£o encontrado para editar.", "error");
                        }
                    });
                });
                showView('category'); // Show the view after content is ready
            }, (error) => {
                console.error("Error loading topics:", error);
                if(currentUser && topicsList) { // Only show error in UI if user is logged in
                    topicsList.innerHTML = '<div class="p-6 text-center text-red-400 bg-gray-800 rounded-lg shadow">Erro ao carregar tÃ³picos.</div>';
                    showModal("Erro ao carregar tÃ³picos: " + error.message);
                }
                showView('category'); // Still show category view, but with error
            });
        }

        /**
         * Handles clicks within the topics list (e.g., to delete, edit, or navigate to a topic).
         */
        async function handleTopicListClick(e) {
            const target = e.target;
            if (target.classList.contains('delete-topic-btn')) { // Clicked delete button
                 e.stopPropagation(); // Prevent navigation
                 const topicId = target.dataset.id;
                 const topicTitle = target.dataset.title;
                 confirmAction(`Tem certeza que deseja excluir o tÃ³pico "${topicTitle}" e todos os seus posts? Esta aÃ§Ã£o Ã© irreversÃ­vel.`, async () => {
                    if (!db) { showModal("ServiÃ§o de banco de dados indisponÃ­vel."); return; }
                    await deleteTopic(topicId);
                });
            } else if (target.classList.contains('user-profile-link')) { // Clicked user profile link
                e.preventDefault();
                e.stopPropagation();
                const userIdToShow = target.dataset.userid;
                if (userIdToShow) showView('userProfile', { userId: userIdToShow });
            } else if (target.closest('.edit-topic-btn-icon')) { // Clicked edit icon (SVG or its path)
                e.stopPropagation(); // Prevent navigation
                const topicId = target.closest('.edit-topic-btn-icon').dataset.topicId;
                const topicRef = doc(topicsCol, topicId);
                const topicSnap = await getDoc(topicRef);
                if (topicSnap.exists()) {
                    openEditTopicModal(topicId, topicSnap.data());
                } else {
                    showModal("TÃ³pico nÃ£o encontrado para editar.", "error");
                }
            } else { // Clicked on topic title or container to navigate
                const topicLink = target.closest('.topic-link-container')?.querySelector('.topic-title-link');
                if (topicLink && topicLink.dataset.id) {
                    const topicId = topicLink.dataset.id;
                    const topicTitle = topicLink.dataset.title;
                    
                    // Increment view count (best effort, don't block navigation for this)
                    const topicRef = doc(topicsCol, topicId);
                    try { 
                        await updateDoc(topicRef, { viewCount: increment(1) });
                    } catch (viewError) {
                        console.warn("Could not update view count:", viewError.message); 
                    }
                    loadPosts(topicId, topicTitle); // Navigate to topic view
                }
            }
        }

        /**
         * Deletes a topic and all its posts.
         * @param {string} topicId - The ID of the topic to delete.
         */
        async function deleteTopic(topicId) {
            const topicRef = doc(topicsCol, topicId);
            const topicSnap = await getDoc(topicRef);
            if (!topicSnap.exists()) {
                showModal("TÃ³pico nÃ£o encontrado.", "error"); return;
            }
            const topicData = topicSnap.data();
            // Permission check: DELETE_ANY_TOPIC or (DELETE_OWN_TOPIC and is creator)
            if (!hasPermission(PERMISSIONS.DELETE_ANY_TOPIC) && !(hasPermission(PERMISSIONS.DELETE_OWN_TOPIC) && currentUser.uid === topicData.createdBy)) {
                showModal("VocÃª nÃ£o tem permissÃ£o para excluir este tÃ³pico.", "error"); return;
            }

            showModal("Excluindo tÃ³pico e seus posts... Isso pode levar um momento.", "info");
            try {
                // 1. Delete all posts in this topic
                const postsInTopicQuery = query(postsCol, where("topicId", "==", topicId));
                const postsSnapshot = await getDocs(postsInTopicQuery);
                let postsDeletedCount = 0;
                for (const postDoc of postsSnapshot.docs) {
                    await deleteDoc(doc(postsCol, postDoc.id));
                    postsDeletedCount++;
                }
                // 2. Delete the topic itself
                await deleteDoc(topicRef);

                // 3. Update category metadata (decrement counts)
                if (topicData.categoryId) { 
                    const categoryRef = doc(categoriesCol, topicData.categoryId); 
                    const categorySnap = await getDoc(categoryRef);
                    if (categorySnap.exists()) {
                        const currentCategoryData = categorySnap.data();
                        let updateData = {
                            topicCount: increment(-1),
                            postCount: increment(-postsDeletedCount) // Decrement by actual number of posts deleted
                        };
                        // If the deleted topic was the last active one, the category's lastActivityDetails
                        // might become stale. It will naturally update when new activity occurs.
                        // For simplicity, we don't try to find the "new" last active topic here.
                        if (currentCategoryData.lastActivityDetails && currentCategoryData.lastActivityDetails.topicId === topicId) {
                            console.log("Deleted topic was last active in category. LastActivityDetails might be stale until new activity.");
                            // Optionally, could try to find the next most recent topic and update lastActivityDetails,
                            // but this adds complexity. For now, let it update on next real activity.
                        }
                        await updateDoc(categoryRef, updateData);
                    }
                }
                showModal("TÃ³pico excluÃ­do com sucesso!", "success");
                // Topic list will refresh via its onSnapshot listener.
            } catch (error) {
                console.error("Error deleting topic:", error);
                showModal("Erro ao excluir tÃ³pico: " + error.message, "error");
            }
        }

        // --- Post Management ---
        let currentTopicId = null; // ID of the current topic being viewed
        let currentTopicTitle = ''; // Title of the current topic (for breadcrumbs, etc.)

        /**
         * Handles the creation of a new post in a topic.
         */
        async function handleCreatePost(e) {
            e.preventDefault();
            if (!hasPermission(PERMISSIONS.CREATE_POST)) {
                 showModal("VocÃª nÃ£o tem permissÃ£o para criar posts.", "error"); return;
            }
            if (!currentUser || !currentTopicId) { // Must be logged in and in a topic
                showModal("VocÃª precisa estar logado e em um tÃ³pico para postar.");
                return;
            }
            const content = e.target.content.value.trim(); // Get content from textarea
            if (!content) {
                showModal("O conteÃºdo da postagem nÃ£o pode estar vazio.");
                return;
            }
            if (containsProhibitedCode(content)) {
                showModal("O conteÃºdo do post contÃ©m cÃ³digo proibido (HTML/JavaScript). Por favor, envie apenas texto.", "error");
                return;
            }
            
            const now = Timestamp.now();
            const userDisplayName = userProfileData?.nickname || userProfileData?.displayName || currentUser.email.split('@')[0];

            try {
                // 1. Create the post document
                await addDoc(postsCol, {
                    topicId: currentTopicId,
                    userId: currentUserId,
                    userDisplayName: userDisplayName, // Store display name at time of posting
                    content,
                    createdAt: now
                });

                // 2. Update topic metadata (reply count, post count, last reply info)
                const topicRef = doc(topicsCol, currentTopicId);
                await updateDoc(topicRef, {
                    replyCount: increment(1),
                    postCount: increment(1), // Also increment topic's total post count
                    lastReplyAt: now,
                    lastReplyBy: currentUserId,
                    lastReplyByDisplayName: userDisplayName
                });
                
                // 3. Update category metadata (post count, last activity info)
                if(currentCategoryId) { // Ensure category context is available
                    const categoryRef = doc(categoriesCol, currentCategoryId); 
                    await updateDoc(categoryRef, {
                        postCount: increment(1), // Increment category's total post count
                        lastActivity: now,
                        lastActivityDetails: {
                            topicId: currentTopicId,
                            topicTitle: currentTopicTitle, // Use the globally set currentTopicTitle
                            userId: currentUserId,
                            userDisplayName: userDisplayName,
                            timestamp: now
                        }
                    });
                }
                showModal("Postagem criada com sucesso!", "success");
                e.target.reset(); // Clear the post content textarea
                // The posts list will update via its onSnapshot listener.
            } catch (error) {
                console.error("Error creating post:", error);
                showModal("Erro ao criar postagem: " + error.message);
            }
        }

        /**
         * Loads and displays posts for a given topic.
         * @param {string} topicId - The ID of the topic.
         * @param {string} topicTitleFromLink - The title of the topic (can be from link, DB is source of truth).
         */
        async function loadPosts(topicId, topicTitleFromLink) {
            if (!db || !postsCol || !userProfilesCol || !topicsCol || !postsList || !topicTitleFull) { 
                if(postsList) postsList.innerHTML = '<div class="p-4 text-center text-red-400">Erro: ServiÃ§o de banco de dados indisponÃ­vel.</div>';
                showView('topic');
                return; 
            }
            if (!currentUser || !userProfileData) { showView('login'); return; } // User must be logged in

            showView('loading');
            currentTopicId = topicId; // Set global context for creating new posts
            
            // Fetch the topic document to get the definitive title and its permissions
            const topicRef = doc(topicsCol, topicId);
            const topicSnap = await getDoc(topicRef);

            if (!topicSnap.exists()) {
                showModal("TÃ³pico nÃ£o encontrado.", "error");
                // Try to go back to category if context exists, otherwise forum home
                showView(currentCategoryId ? 'category' : 'forumHome'); 
                return;
            }
            const topicData = topicSnap.data();
            currentTopicTitle = topicData.title; // Use title from DB as the source of truth
            topicTitleFull.textContent = currentTopicTitle; // Display topic title in view


            // --- Permission check for viewing this specific topic ---
            let canViewThisTopic = false;
            if (isAdmin) { // Admins can view all topics
                canViewThisTopic = true;
            } else {
                const topicSpecificRoles = topicData.allowedRoles;
                if (topicSpecificRoles && topicSpecificRoles.length > 0) { // Topic has its own role restrictions
                    if (userProfileData && topicSpecificRoles.includes(userProfileData.role)) {
                        canViewThisTopic = true;
                    }
                } else { // Topic inherits permissions from its category
                    let categoryAllowedRolesForTopic = currentCategoryAllowedRoles; // Use if already set from category view
                    // If navigating directly to topic (e.g. via link), category context might not be set
                    // So, fetch parent category to check its roles
                    if (topicData.categoryId && (!currentCategoryId || currentCategoryId !== topicData.categoryId)) {
                        const parentCategoryRef = doc(categoriesCol, topicData.categoryId);
                        const parentCategorySnap = await getDoc(parentCategoryRef);
                        if (parentCategorySnap.exists()) {
                            categoryAllowedRolesForTopic = parentCategorySnap.data().allowedRoles || [];
                            // Update global category context for breadcrumbs if it was missing/different
                            currentCategoryName = parentCategorySnap.data().name; 
                            currentCategoryId = topicData.categoryId;
                        } else {
                             categoryAllowedRolesForTopic = []; // Category not found, assume restricted by default
                             console.warn(`Parent category ${topicData.categoryId} for topic ${topicId} not found.`);
                        }
                    }
                    
                    // If category is public OR user's role is allowed by category
                    if (categoryAllowedRolesForTopic.length === 0 || (userProfileData && categoryAllowedRolesForTopic.includes(userProfileData.role))) {
                        canViewThisTopic = true;
                    }
                }
            }

            if (!canViewThisTopic) {
                showModal("VocÃª nÃ£o tem permissÃ£o para visualizar este tÃ³pico.", "error");
                showView(currentCategoryId ? 'category' : 'forumHome'); // Go back
                return;
            }
            
            // Update breadcrumbs now that category context is confirmed/fetched
            updateBreadcrumbs([
                {name: currentCategoryName || "Categoria", view: 'category', id: currentCategoryId}, 
                {name: currentTopicTitle, view: 'topic', id: topicId} // This 'topic' view in breadcrumb is conceptual
            ]);


            // Clear any previous poll (if polls were implemented)
            if (document.getElementById('topic-poll-container')) document.getElementById('topic-poll-container').innerHTML = ''; 

            postsList.innerHTML = '<div class="loading-spinner"></div><p class="text-gray-400 text-center">Carregando postagens...</p>';
            const q = query(postsCol, where("topicId", "==", topicId)); // Get posts for this topic
            // Posts will be sorted client-side by createdAt

            if(unsubscribePosts) unsubscribePosts(); // Clear previous listener
            unsubscribePosts = onSnapshot(q, async (snapshot) => {
                if (!currentUser) return; // If user logs out
                if (snapshot.empty) {
                    // Topic exists (checked above), so it's just empty of posts (e.g., first post deleted)
                    postsList.innerHTML = '<div class="p-6 text-center text-gray-400 bg-gray-800 rounded-lg shadow">Nenhuma postagem encontrada neste tÃ³pico. Seja o primeiro a responder!</div>';
                    showView('topic');
                    return;
                }

                // Fetch user profiles for post authors
                const userIds = new Set(snapshot.docs.map(d => d.data().userId).filter(id => id)); // Filter out undefined IDs
                const profiles = {}; // Cache for fetched profiles
                 if (userIds.size > 0) {
                    const profilePromises = Array.from(userIds).map(uid => getDoc(doc(userProfilesCol, uid)));
                     try {
                        const profileSnaps = await Promise.all(profilePromises);
                        profileSnaps.forEach(snap => {
                            if (snap.exists()) {
                                const data = snap.data();
                                profiles[snap.id] = {
                                    displayName: data.nickname || data.displayName || data.email?.split('@')[0] || 'Desconhecido',
                                    role: data.role || 'Membro' // Get role for styling
                                };
                            } else { // Should not happen if users can't be deleted, but good practice
                                profiles[snap.id] = { displayName: 'UsuÃ¡rio Deletado', role: 'Membro' };
                            }
                        });
                    } catch (err) { console.error("Error fetching user profiles for posts:", err); }
                }
                
                // Sort posts by creation time (ascending)
                const docsToSort = [...snapshot.docs];
                const sortedDocs = docsToSort.sort((a,b) => {
                    const timeA = a.data().createdAt?.seconds || 0;
                    const timeB = b.data().createdAt?.seconds || 0;
                    return timeA - timeB; // Oldest first
                });

                let postsHtml = '';
                sortedDocs.forEach((postDoc, index) => { // Index for identifying first post (for command button)
                    const post = postDoc.data();
                    const userProfile = profiles[post.userId];
                    const displayName = userProfile?.displayName || post.userDisplayName || 'Desconhecido';
                    const userRole = userProfile?.role || 'Membro'; 
                    const roleColor = currentRoleColors[userRole] || '#6b7280'; // Default color if role/color not found
                    const postContent = post.content ? post.content.replace(/\n/g, '<br>') : ""; // Preserve line breaks

                    // Comandos para copiar no primeiro post
                    let commandsHtml = '';
                    if (index === 0 && Array.isArray(post.topicCommands) && post.topicCommands.length > 0) {
                        commandsHtml = '<div class="mb-2">';
                        post.topicCommands.forEach(cmd => {
                            commandsHtml += `<div class='flex items-center space-x-2 mb-1'>
                                <span class='text-xs font-semibold text-yellow-300'>${cmd.nome || ''}:</span>
                                <span class='text-xs bg-gray-700 px-2 py-1 rounded'>${cmd.comando || ''}</span>
                                <button class='copy-post-command-btn bg-indigo-500 hover:bg-indigo-600 text-white text-xs py-1 px-2 rounded' data-command="${cmd.comando}">Copiar</button>
                            </div>`;
                        });
                        commandsHtml += '</div>';
                    }
                    
                    // Edit/Delete actions for posts
                    let actionsHtml = '';
                    // Edit: User with EDIT_ANY_POST OR (user with EDIT_OWN_POST AND is author)
                    if (hasPermission(PERMISSIONS.EDIT_ANY_POST) || (hasPermission(PERMISSIONS.EDIT_OWN_POST) && currentUser.uid === post.userId)) {
                        actionsHtml += `<button class="edit-post-btn text-yellow-500 hover:text-yellow-400 text-xs mt-2 p-1 mr-2" data-post-id="${postDoc.id}">Editar</button>`;
                    }
                    // Delete: User with DELETE_ANY_POST OR (user with DELETE_OWN_POST AND is author)
                    if (hasPermission(PERMISSIONS.DELETE_ANY_POST) || (hasPermission(PERMISSIONS.DELETE_OWN_POST) && currentUser.uid === post.userId)) { 
                         actionsHtml += `<button class="delete-post-btn text-red-500 hover:text-red-400 text-xs mt-2 p-1" data-id="${postDoc.id}" data-topic-id="${post.topicId}">Excluir</button>`;
                    }

                    postsHtml += `
                        <div class="bg-gray-800 p-4 rounded-lg shadow mb-4">
                            <div class="flex justify-between items-start mb-2">
                                <p class="text-sm text-blue-400 font-semibold">
                                    <a href="#" class="user-profile-link hover:underline" data-userid="${post.userId}">${displayName}</a>
                                    <span class="role-tag" style="background-color: ${roleColor};">${userRole}</span>
                                </p>
                                <p class="text-xs text-gray-500">${formatTimestamp(post.createdAt)} ${post.lastEditedAt ? `(editado ${formatTimestamp(post.lastEditedAt)})` : ''}</p>
                            </div>
                            <div id="post-content-${postDoc.id}" class="text-gray-300">${postContent}</div>
                            ${commandsHtml}
                            <div class="mt-2">${actionsHtml}</div>
                        </div>
                    `;
                });
                postsList.innerHTML = postsHtml;
                addProfileLinkListeners(postsList); // Attach listeners for user profile links in posts
                // Add listeners for "Copy Command" buttons
                postsList.querySelectorAll('.copy-post-command-btn').forEach(button => {
                    button.addEventListener('click', (e) => copyToClipboard(e.target.dataset.command));
                });
                // Add listeners for "Edit Post" buttons
                postsList.querySelectorAll('.edit-post-btn').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const postId = e.target.dataset.postId;
                        const postRef = doc(postsCol, postId);
                        const postSnap = await getDoc(postRef);
                        if (postSnap.exists()) {
                            openEditPostModal(postId, postSnap.data().content); // Open modal with post content
                        } else {
                            showModal("Post nÃ£o encontrado para editar.", "error");
                        }
                    });
                });
                showView('topic'); // Show the view after content is ready
            }, (error) => {
                console.error("Error loading posts:", error);
                if (currentUser && postsList) { // Only show error in UI if user is logged in
                    postsList.innerHTML = '<div class="p-6 text-center text-red-400 bg-gray-800 rounded-lg shadow">Erro ao carregar postagens.</div>';
                    showModal("Erro ao carregar postagens: " + error.message);
                }
                showView('topic'); // Still show topic view, but with error
            });
        }

        /**
         * Handles clicks within the posts list (e.g., to delete a post or view a user profile).
         */
        async function handlePostListClick(e) {
            if (e.target.classList.contains('delete-post-btn')) { // Clicked delete button
                const postId = e.target.dataset.id;
                const postRef = doc(postsCol, postId);
                const postSnap = await getDoc(postRef); 
                if (!postSnap.exists()) {
                    showModal("Post nÃ£o encontrado.", "error"); return;
                }
                const postData = postSnap.data();
                // Permission check for deleting post
                if (!hasPermission(PERMISSIONS.DELETE_ANY_POST) && !(hasPermission(PERMISSIONS.DELETE_OWN_POST) && currentUser.uid === postData.userId)) {
                    showModal("VocÃª nÃ£o tem permissÃ£o para excluir este post.", "error"); return;
                }

                confirmAction("Tem certeza que deseja excluir este post? Esta aÃ§Ã£o Ã© irreversÃ­vel.", async () => {
                    try {
                        await deleteDoc(postRef); 
                        // Update topic and category counts
                        if (postData.topicId) {
                            const topicRef = doc(topicsCol, postData.topicId);
                            await updateDoc(topicRef, { 
                                replyCount: increment(-1), // If it's a reply. First post deletion is more complex.
                                postCount: increment(-1) 
                                // TODO: Handle if first post is deleted (topic might need to be deleted or handled differently)
                                // For now, assumes any post deletion decrements counts.
                            });
                        }
                        if(currentCategoryId) { // If category context is known
                            const categoryRef = doc(categoriesCol, currentCategoryId);
                            await updateDoc(categoryRef, { postCount: increment(-1) });
                        }
                        showModal("Post excluÃ­do com sucesso!", "success");
                        // Posts list will update via its onSnapshot listener.
                    } catch (error) {
                        console.error("Error deleting post:", error);
                        showModal("Erro ao excluir post: " + error.message, "error");
                    }
                });
            } else if (e.target.classList.contains('user-profile-link')) { // Clicked user profile link
                e.preventDefault();
                const userIdToShow = e.target.dataset.userid;
                if (userIdToShow) showView('userProfile', { userId: userIdToShow });
            }
        }
        
        /**
         * Attaches event listeners to user profile links within a given parent element.
         * Clones and replaces nodes to avoid issues with stale listeners.
         * @param {HTMLElement} parentElement - The element containing user profile links.
         */
        function addProfileLinkListeners(parentElement) {
            if (!parentElement) return;
            parentElement.querySelectorAll('.user-profile-link').forEach(link => {
                // Clone and replace to ensure fresh event listeners, especially if content is re-rendered
                const newLink = link.cloneNode(true);
                link.parentNode.replaceChild(newLink, link);

                newLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    const userIdToShow = e.target.dataset.userid;
                    if (userIdToShow) showView('userProfile', { userId: userIdToShow });
                });
            });
        }

        // --- Edit Post Functionality ---
        /**
         * Opens the modal to edit a post.
         * @param {string} postId - The ID of the post to edit.
         * @param {string} currentContent - The current content of the post.
         */
        function openEditPostModal(postId, currentContent) {
            if (!editPostModal || !editPostContentInput) return;
            editingPostId = postId; // Store globally for save function
            editPostContentInput.value = currentContent; // Populate textarea
            editPostModal.style.display = 'flex'; // Show modal
        }

        /**
         * Saves the edited content of a post.
         */
        async function saveEditedPost() {
            if (!editingPostId || !editPostContentInput || !editPostModal) return;
            const postRef = doc(postsCol, editingPostId);
            const postSnap = await getDoc(postRef);
            if (!postSnap.exists()) {
                showModal("Post nÃ£o encontrado para editar.", "error"); return;
            }
            const postData = postSnap.data();

            // Permission check for editing post
            if (!hasPermission(PERMISSIONS.EDIT_ANY_POST) && !(hasPermission(PERMISSIONS.EDIT_OWN_POST) && currentUser.uid === postData.userId)) {
                showModal("VocÃª nÃ£o tem permissÃ£o para editar este post.", "error"); return;
            }

            const newContent = editPostContentInput.value.trim();
            if (!newContent) {
                showModal("O conteÃºdo do post nÃ£o pode ficar vazio.", "error");
                return;
            }
            if (containsProhibitedCode(newContent)) {
                showModal("O conteÃºdo editado contÃ©m cÃ³digo proibido (HTML/JavaScript). Por favor, envie apenas texto.", "error");
                return;
            }
            try {
                await updateDoc(postRef, {
                    content: newContent,
                    lastEditedAt: Timestamp.now(),
                    lastEditedBy: currentUserId, // Track who edited
                    lastEditedByDisplayName: userProfileData?.nickname || userProfileData?.displayName || currentUser.email.split('@')[0]
                });
                showModal("Post atualizado com sucesso!", "success");
                editPostModal.style.display = 'none'; // Close modal
                editingPostId = null; // Clear global ID
                // Post list will update via its onSnapshot listener.
            } catch (error) {
                console.error("Error updating post:", error);
                showModal("Erro ao atualizar post: " + error.message, "error");
            }
        }

        // --- Edit Topic Functionality ---
        /**
         * Opens the modal to edit a topic's title and role permissions.
         * @param {string} topicId - The ID of the topic to edit.
         * @param {object} currentTopic - The current data of the topic.
         */
        function openEditTopicModal(topicId, currentTopic) {
            if (!editTopicModal || !editTopicTitleInput || !editTopicRolePermissionsContainer) return;
            editingTopicId = topicId; // Store globally
            editingTopicData = currentTopic; // Store full topic data for permission checks on save

            editTopicTitleInput.value = currentTopic.title || '';
            // Populate role checkboxes with current topic's allowed roles
            populateTopicRolePermissionsCheckboxes(editTopicRolePermissionsContainer, currentTopic.allowedRoles || []);
            editTopicModal.style.display = 'flex'; // Show modal
        }

        /**
         * Saves the edited title and role permissions of a topic.
         */
        async function saveEditedTopic() {
            if (!editingTopicId || !editingTopicData || !editTopicTitleInput || !editTopicRolePermissionsContainer || !editTopicModal) return;

            // Permission check: Topic creator OR user with MANAGE_CATEGORIES (as proxy for "manage any topic")
            if (!(currentUser.uid === editingTopicData.createdBy || hasPermission(PERMISSIONS.MANAGE_CATEGORIES))) {
                showModal("VocÃª nÃ£o tem permissÃ£o para editar este tÃ³pico.", "error");
                return;
            }

            const newTitle = editTopicTitleInput.value.trim();
            if (!newTitle) {
                showModal("O tÃ­tulo do tÃ³pico nÃ£o pode ficar vazio.", "error");
                return;
            }

            const selectedRoles = []; // Get newly selected roles for the topic
            const checkboxes = document.querySelectorAll('#edit-topic-role-permissions-container input[name="topicAllowedRoles"]:checked');
            checkboxes.forEach(checkbox => selectedRoles.push(checkbox.value));

            try {
                const topicRef = doc(topicsCol, editingTopicId);
                await updateDoc(topicRef, {
                    title: newTitle,
                    allowedRoles: selectedRoles.length > 0 ? selectedRoles : [] // Store empty array if none (public/inherit)
                });
                showModal("TÃ³pico atualizado com sucesso!", "success");
                editTopicModal.style.display = 'none'; // Close modal
                editingTopicId = null; // Clear global IDs
                editingTopicData = null;
                // The topics list will refresh via its onSnapshot listener.
            } catch (error) {
                console.error("Error updating topic:", error);
                showModal("Erro ao atualizar tÃ³pico: " + error.message, "error");
            }
        }


        // --- Gemini API Integration (AI Helpers) ---
        /**
         * Calls the Gemini API to generate text based on a prompt.
         * @param {string} prompt - The prompt to send to the API.
         * @param {string} loadingElementId - ID of the spinner element to show/hide.
         * @returns {Promise<string|null>} The generated text or null on error.
         */
        async function callGeminiAPI(prompt, loadingElementId) {
            const loadingSpinner = document.getElementById(loadingElementId);
            if (loadingSpinner) loadingSpinner.style.display = 'inline-block'; // Show spinner

            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = ""; // API Key will be injected by the Canvas environment if needed
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) { // Handle API errors
                    const errorData = await response.json().catch(() => ({ error: { message: "Resposta nÃ£o JSON da API." }}));
                    console.error("Gemini API Error Response:", errorData);
                    throw new Error(`Erro da API Gemini: ${response.status} ${response.statusText}. Detalhes: ${JSON.stringify(errorData.error?.message || errorData)}`);
                }
                const result = await response.json();
                // Extract text from the response
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else { // Unexpected response structure
                    console.warn("Resposta inesperada da API Gemini:", result);
                    throw new Error("Resposta inesperada da API Gemini ou conteÃºdo ausente.");
                }
            } catch (error) {
                console.error("Falha ao chamar a API Gemini:", error);
                showModal("Falha ao comunicar com a IA: " + error.message, "error");
                return null;
            } finally {
                if (loadingSpinner) loadingSpinner.style.display = 'none'; // Hide spinner
            }
        }

        /**
         * Generates a category description using the Gemini API.
         */
        async function generateCategoryDescription() {
            if (!categoryNameInput || !categoryDescriptionInput) return;
            const categoryName = categoryNameInput.value.trim();
            if (!categoryName) {
                showModal("Por favor, insira um nome para a categoria primeiro.", "error");
                return;
            }
            const prompt = `Gere uma descriÃ§Ã£o curta e concisa (mÃ¡ximo 2 frases) para uma categoria de fÃ³rum chamada "${categoryName}". A descriÃ§Ã£o deve ser convidativa e em portuguÃªs do Brasil.`;
            const generatedDescription = await callGeminiAPI(prompt, 'generate-category-desc-spinner');
            if (generatedDescription) {
                categoryDescriptionInput.value = generatedDescription.trim();
                showModal("DescriÃ§Ã£o gerada pela IA!", "success");
            }
        }

        /**
         * Suggests a topic title using the Gemini API based on the first post content.
         */
        async function suggestTopicTitle() {
            if (!newTopicContentInput || !newTopicTitleInput) return;
            const topicContent = newTopicContentInput.value.trim();
            if (!topicContent) {
                showModal("Por favor, escreva o conteÃºdo da primeira postagem primeiro.", "error");
                return;
            }
            // Use a substring of content to keep prompt concise
            const prompt = `Sugira um tÃ­tulo curto e chamativo (mÃ¡ximo 10 palavras) para um tÃ³pico de fÃ³rum cujo primeiro post tem o seguinte conteÃºdo (em portuguÃªs do Brasil):\n\n"${topicContent.substring(0, 500)}${topicContent.length > 500 ? '...' : ''}"\n\nO tÃ­tulo deve ser em portuguÃªs do Brasil.`;
            const suggestedTitle = await callGeminiAPI(prompt, 'suggest-topic-title-spinner');
            if (suggestedTitle) {
                newTopicTitleInput.value = suggestedTitle.replace(/"/g, '').trim(); // Remove quotes from AI response
                showModal("TÃ­tulo sugerido pela IA!", "success");
            }
        }
        
        // --- User Profile Management (My Profile & Public View) ---
        /**
         * Loads the current user's data into the "My Profile" view.
         */
        function loadMyProfileView() {
            if (!currentUser || !userProfileData || !myProfileNicknameInput || !myProfileSteamUrlInput || !myProfileEmailDisplay || !myProfileRoleDisplay) {
                showModal("VocÃª precisa estar logado para ver seu perfil.", "error");
                showView('login'); // Redirect if data not available
                return;
            }
            myProfileNicknameInput.value = userProfileData.nickname || '';
            myProfileSteamUrlInput.value = userProfileData.steamProfileUrl || '';
            myProfileEmailDisplay.textContent = currentUser.email; // Email from auth object
            myProfileRoleDisplay.textContent = userProfileData.role || 'Membro';
            // Style role tag with its color
            const roleColor = currentRoleColors[userProfileData.role] || '#6b7280'; // Default color
            myProfileRoleDisplay.style.backgroundColor = roleColor;
            if (!myProfileRoleDisplay.classList.contains('role-tag')) { // Ensure class is present
                myProfileRoleDisplay.classList.add('role-tag');
            }
        }

        /**
         * Saves changes made by the user to their own profile.
         */
        async function saveMyProfile() {
            if (!currentUser || !db || !myProfileNicknameInput || !myProfileSteamUrlInput) {
                showModal("NÃ£o foi possÃ­vel salvar o perfil. Tente novamente.", "error");
                return;
            }
            const newNickname = myProfileNicknameInput.value.trim();
            const newSteamUrl = myProfileSteamUrlInput.value.trim();

            const profileRef = doc(userProfilesCol, currentUserId);
            try {
                await updateDoc(profileRef, {
                    nickname: newNickname,
                    steamProfileUrl: newSteamUrl,
                    // lastSeen will be updated by the onAuthStateChanged listener or other activities
                });
                showModal("Perfil atualizado com sucesso!", "success");
                // userProfileData will be updated by its onSnapshot listener.
            } catch (error) {
                console.error("Error updating profile:", error);
                showModal("Erro ao atualizar perfil: " + error.message, "error");
            }
        }

        /**
         * Loads and displays a public user profile.
         * @param {string} userId - The ID of the user whose profile to display.
         */
        async function loadUserProfileView(userId) {
            if (!db || !userProfilesCol || !userProfileViewDisplayName) { 
                 showModal("ServiÃ§o de banco de dados indisponÃ­vel ou UI nÃ£o pronta."); return;
            }
            showView('loading'); // Show loading while fetching profile
            const profileRef = doc(userProfilesCol, userId);
            try {
                const docSnap = await getDoc(profileRef);
                if (docSnap.exists()) {
                    const profile = docSnap.data();
                    userProfileViewDisplayName.textContent = profile.displayName || 'N/A';
                    userProfileViewNickname.textContent = profile.nickname || 'Nenhum';
                    // Show full email only to admins or the user themselves
                    const canViewFullEmail = hasPermission(PERMISSIONS.MANAGE_USERS) || currentUserId === userId;
                    userProfileViewEmail.textContent = canViewFullEmail ? profile.email : (profile.email ? profile.email.split('@')[0] + '@...' : 'N/A');
                    
                    userProfileViewRole.textContent = profile.role || 'Membro';
                    const roleColor = currentRoleColors[profile.role] || '#6b7280';
                    userProfileViewRole.style.backgroundColor = roleColor;
                    if (!userProfileViewRole.classList.contains('role-tag')) {
                         userProfileViewRole.classList.add('role-tag');
                    }

                    // Display Steam profile link if available
                    if (profile.steamProfileUrl && userProfileViewSteamLink) {
                        userProfileViewSteamLink.href = profile.steamProfileUrl;
                        userProfileViewSteamLink.textContent = profile.steamProfileUrl;
                        userProfileViewSteamLink.parentElement.style.display = 'block'; // Show the <p> container
                    } else if (userProfileViewSteamLink) {
                        userProfileViewSteamLink.parentElement.style.display = 'none'; // Hide if no URL
                    }
                    if(userProfileViewRegisteredDate) userProfileViewRegisteredDate.textContent = formatTimestamp(profile.createdAt);
                    showView('userProfile'); // Show the view after populating
                } else {
                    showModal("Perfil de usuÃ¡rio nÃ£o encontrado.", "error");
                    showView('forumHome'); // Go back if profile not found
                }
            } catch (error) {
                console.error("Error loading user profile:", error);
                showModal("Erro ao carregar perfil: " + error.message, "error");
                showView('forumHome'); // Go back on error
            }
        }
        
        // --- Admin Panel: Role Color & Server/Permissions Config ---
        /**
         * Loads role color settings into the admin panel.
         * Uses `currentRoleColors` which is kept up-to-date by `loadServerConfig`.
         */
        async function loadRoleColorSettings() { 
            if (!db || !serverConfigDocRef || !hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS) || !adminRoleColorSettings) return;
            adminRoleColorSettings.innerHTML = '<p class="text-gray-400">Carregando configuraÃ§Ãµes de cores...</p>';
            try {
                let html = '';
                defaultRoles.forEach(role => {
                    html += `
                        <div class="flex items-center space-x-2 mb-2">
                            <label for="role-color-${role}" class="w-24">${role}:</label>
                            <input type="color" id="role-color-${role}" value="${currentRoleColors[role] || '#6b7280'}" class="h-8 w-12 p-0 border-none rounded">
                            <input type="text" id="role-hex-${role}" value="${currentRoleColors[role] || '#6b7280'}" placeholder="#RRGGBB" class="p-1 bg-gray-600 border border-gray-500 rounded-md text-gray-100 w-24">
                        </div>
                    `;
                });
                adminRoleColorSettings.innerHTML = html;

                // Add event listeners to sync color picker and hex input
                defaultRoles.forEach(role => {
                    const colorPicker = document.getElementById(`role-color-${role}`);
                    const hexInput = document.getElementById(`role-hex-${role}`);
                    if (colorPicker && hexInput) {
                        colorPicker.addEventListener('input', (e) => hexInput.value = e.target.value);
                        hexInput.addEventListener('input', (e) => { // Validate hex input
                            if (/^#[0-9A-F]{6}$/i.test(e.target.value)) { 
                                colorPicker.value = e.target.value;
                            }
                        });
                    }
                });

            } catch (error) { // Should not happen as data comes from live config
                console.error("Error displaying role color settings (should be from live config):", error);
                adminRoleColorSettings.innerHTML = '<p class="text-red-400">Erro ao carregar cores.</p>';
            }
        }

        /**
         * Saves role color configurations from the admin panel to Firestore.
         */
        async function saveRoleColors() {
            if (!hasPermission(PERMISSIONS.MANAGE_FORUM_SETTINGS)) { 
                 showModal("VocÃª nÃ£o tem permissÃ£o para gerenciar configuraÃ§Ãµes.", "error"); return;
            }
            const newRoleColors = {};
            let allValid = true;
            defaultRoles.forEach(role => {
                const hexValue = document.getElementById(`role-hex-${role}`).value.trim();
                if (/^#[0-9A-F]{6}$/i.test(hexValue)) { // Validate hex format
                    newRoleColors[role] = hexValue;
                } else {
                    showModal(`Cor invÃ¡lida para ${role}: ${hexValue}. Use formato #RRGGBB.`, "error");
                    allValid = false;
                }
            });

            if (!allValid) return; // Don't save if any color is invalid

            try {
                await setDoc(serverConfigDocRef, { roleColors: newRoleColors }, { merge: true });
                showModal("Cores dos cargos salvas com sucesso!", "success");
                // `currentRoleColors` will be updated by the `loadServerConfig` onSnapshot listener.
            } catch (error) {
                console.error("Error saving role colors:", error);
                showModal("Erro ao salvar cores: " + error.message, "error");
            }
        }
        
        /**
         * Loads server-wide configuration (forum name, registrations, roles, permissions, CS servers).
         * Attaches a listener for real-time updates to this configuration.
         * @returns {Promise} Resolves when initial config is loaded, rejects on critical error.
         */
        async function loadServerConfig() { 
            return new Promise((resolve, reject) => {
                if (!db || !serverConfigDocRef) { 
                    console.warn("loadServerConfig: DB or serverConfigDocRef not available. Using hardcoded defaults and attempting to make registrations closed as a safe default.");
                    currentRoleColors = { Admin: "#FF0000", Moderador: "#00FF00", VIP: "#0000FF", Membro: "#808080" };
                    registrationsOpen = false; // Safe default if config is inaccessible
                    serverRolePermissionsConfig = { Admin: Object.fromEntries(Object.values(PERMISSIONS).map(p => [p, true])) };
                     defaultRoles.forEach(role => { 
                        if (!serverRolePermissionsConfig[role]) serverRolePermissionsConfig[role] = {};
                        if (role === 'Membro' && Object.keys(serverRolePermissionsConfig[role]).length === 0) { 
                             serverRolePermissionsConfig[role][PERMISSIONS.CREATE_TOPIC] = true;
                             serverRolePermissionsConfig[role][PERMISSIONS.CREATE_POST] = true;
                             serverRolePermissionsConfig[role][PERMISSIONS.EDIT_OWN_POST] = true;
                             serverRolePermissionsConfig[role][PERMISSIONS.DELETE_OWN_POST] = true;
                             serverRolePermissionsConfig[role][PERMISSIONS.DELETE_OWN_TOPIC] = true;
                        }
                    });
                    if (userProfileData && userProfileData.role) { 
                        currentRolePermissions = serverRolePermissionsConfig[userProfileData.role] || {};
                    } else {
                        currentRolePermissions = {};
                    }
                    // Update UI elements based on this safe default
                    if (registerNav) registerNav.style.display = 'none';
                    if (registerPromptContainer) registerPromptContainer.style.display = 'none';
                    resolve(); 
                    return;
                }

                if (unsubscribeServerConfig) unsubscribeServerConfig(); 
                let initialLoadDone = false; 

                unsubscribeServerConfig = onSnapshot(serverConfigDocRef, (docSnap) => {
                    let configData = {};
                    if (docSnap.exists()) {
                        configData = docSnap.data();
                    } else { 
                        console.log("Server config not found in Firestore, using defaults and attempting to create.");
                        configData = {
                            forumName: "Negativa Server - FÃ³rum",
                            registrationsOpen: true, // Default to true for a *new* setup
                            roleColors: { Admin: "#D32F2F", Moderador: "#1976D2", VIP: "#7B1FA2", Membro: "#616161" }, 
                            rolePermissions: {}, 
                            csServers: [] 
                        };
                        defaultRoles.forEach(role => {
                            configData.rolePermissions[role] = {};
                            if (role === 'Admin') { 
                                Object.values(PERMISSIONS).forEach(perm => configData.rolePermissions[role][perm] = true);
                            } else if (role === 'Membro') { 
                                configData.rolePermissions[role][PERMISSIONS.CREATE_TOPIC] = true;
                                configData.rolePermissions[role][PERMISSIONS.CREATE_POST] = true;
                                configData.rolePermissions[role][PERMISSIONS.EDIT_OWN_POST] = true;
                                configData.rolePermissions[role][PERMISSIONS.DELETE_OWN_POST] = true;
                                configData.rolePermissions[role][PERMISSIONS.DELETE_OWN_TOPIC] = true;
                            }
                        });
                        setDoc(serverConfigDocRef, configData)
                            .then(() => console.log("Default server config saved to Firestore."))
                            .catch(err => console.error("Error saving default server config:", err));
                    }

                    currentRoleColors = configData.roleColors || { Admin: "#D32F2F", Moderador: "#1976D2", VIP: "#7B1FA2", Membro: "#616161" };
                    registrationsOpen = configData.registrationsOpen === undefined ? true : configData.registrationsOpen;
                    serverRolePermissionsConfig = configData.rolePermissions || {};
                    
                    if (Object.keys(serverRolePermissionsConfig).length === 0) { 
                         defaultRoles.forEach(role => {
                            serverRolePermissionsConfig[role] = {};
                            if (role === 'Admin') {
                                Object.values(PERMISSIONS).forEach(perm => serverRolePermissionsConfig[role][perm] = true);
                            } else if (role === 'Membro') { 
                                serverRolePermissionsConfig[role][PERMISSIONS.CREATE_TOPIC] = true;
                                serverRolePermissionsConfig[role][PERMISSIONS.CREATE_POST] = true;
                                serverRolePermissionsConfig[role][PERMISSIONS.EDIT_OWN_POST] = true;
                                serverRolePermissionsConfig[role][PERMISSIONS.DELETE_OWN_POST] = true;
                                serverRolePermissionsConfig[role][PERMISSIONS.DELETE_OWN_TOPIC] = true;
                            }
                        });
                    }

                    if (userProfileData && userProfileData.role) {
                        currentRolePermissions = serverRolePermissionsConfig[userProfileData.role] || {};
                    }

                    if (forumTitleHeader) forumTitleHeader.textContent = configData.forumName || "Negativa Server - FÃ³rum";
                    if (forumTitleTag) forumTitleTag.textContent = configData.forumName || "Negativa Server - FÃ³rum";
                    loadPublicCsServerBanners(configData.csServers || []); 

                    if (registerNav) registerNav.style.display = registrationsOpen ? 'inline-block' : 'none';
                    if (registerPromptContainer) { 
                        registerPromptContainer.style.display = registrationsOpen ? 'block' : 'none';
                    }
                    if (adminRegistrationsToggle && isAdmin) adminRegistrationsToggle.checked = registrationsOpen; 

                    if (isAdmin && adminControls && adminControls.style.display === 'block') {
                        loadRolePermissionsSettings(); 
                        loadRoleColorSettings(); 
                        populateCategoryRolePermissionsCheckboxes(); 
                        populateTopicRolePermissionsCheckboxes(topicRolePermissionsContainer); 
                    }
                    console.log("[Client] Server config loaded/updated via listener. Registrations Open:", registrationsOpen);

                    if (!initialLoadDone) {
                        initialLoadDone = true;
                        resolve();
                    }
                }, (error) => { 
                    console.error("Error in serverConfig onSnapshot listener:", error);
                    currentRoleColors = { Admin: "#D32F2F", Moderador: "#1976D2", VIP: "#7B1FA2", Membro: "#616161" };
                    registrationsOpen = false; // << SAFER DEFAULT IN CASE OF LISTENER ERROR
                    serverRolePermissionsConfig = { Admin: Object.fromEntries(Object.values(PERMISSIONS).map(p => [p, true])) };
                     defaultRoles.forEach(role => {
                        if (!serverRolePermissionsConfig[role]) serverRolePermissionsConfig[role] = {};
                         if (role === 'Membro' && Object.keys(serverRolePermissionsConfig[role]).length === 0) {
                             serverRolePermissionsConfig[role][PERMISSIONS.CREATE_TOPIC] = true;
                         }
                    });
                    if (userProfileData && userProfileData.role) {
                        currentRolePermissions = serverRolePermissionsConfig[userProfileData.role] || {};
                    }
                    
                    // Update UI elements to reflect the safer default
                    if (forumTitleHeader) forumTitleHeader.textContent = "Negativa Server - FÃ³rum";
                    if (forumTitleTag) forumTitleTag.textContent = "Negativa Server - FÃ³rum";
                    if (registerNav) registerNav.style.display = registrationsOpen ? 'inline-block' : 'none'; // Should be 'none'
                    if (registerPromptContainer) registerPromptContainer.style.display = registrationsOpen ? 'block' : 'none'; // Should be 'none'
                    loadPublicCsServerBanners([]); 

                    if (!initialLoadDone) {
                        initialLoadDone = true;
                        reject(error); 
                    } else {
                        showModal("Erro ao carregar configuraÃ§Ãµes do servidor. Cadastros podem estar temporariamente indisponÃ­veis.", "error");
                    }
                });
            });
        }
        
        /**
         * Loads and displays recently active members in the aside panel.
         */
        async function loadRecentMembers() {
            if (!db || !userProfilesCol || !recentMembersList) {
                if(recentMembersList) recentMembersList.innerHTML = '<p class="text-xs text-gray-500">NÃ£o foi possÃ­vel carregar.</p>';
                return;
            }
            if (unsubscribeRecentMembers) unsubscribeRecentMembers(); // Clear previous listener

            // Query for users, ordered by lastSeen, limited to 5
            const q = query(userProfilesCol, orderBy("lastSeen", "desc"), limit(5));
            unsubscribeRecentMembers = onSnapshot(q, (snapshot) => {
                // Don't show if user is not logged in AND registrations are closed (very niche, but covers edge case)
                 if (!currentUser && !registrationsOpen) { 
                     recentMembersList.innerHTML = ''; return;
                 }
                if (snapshot.empty) {
                    recentMembersList.innerHTML = '<p class="text-xs text-gray-500">Nenhum membro online recentemente.</p>';
                    return;
                }
                let membersHtml = '<h4 class="text-md font-semibold text-gray-300 mb-2">Online Recentemente:</h4><ul class="space-y-1">';
                snapshot.forEach(doc => {
                    const member = doc.data();
                    const displayName = member.nickname || member.displayName || member.email?.split('@')[0] || 'UsuÃ¡rio';
                    const roleColor = currentRoleColors[member.role] || '#6b7280'; // Use current server config for colors
                    membersHtml += `
                        <li class="text-xs">
                            <a href="#" class="user-profile-link text-blue-400 hover:underline" data-userid="${doc.id}">${displayName}</a>
                            <span class="role-tag" style="background-color: ${roleColor};">${member.role || 'Membro'}</span>
                            <span class="text-gray-500 ml-1">(${formatTimestamp(member.lastSeen)})</span>
                        </li>`;
                });
                membersHtml += '</ul>';
                recentMembersList.innerHTML = membersHtml;
                addProfileLinkListeners(recentMembersList); // Add listeners for profile links
            }, (error) => {
                console.error("Error loading recent members:", error);
                if(recentMembersList) recentMembersList.innerHTML = '<p class="text-xs text-red-500">Erro ao carregar membros.</p>';
            });
        }

        // --- Chat Functionality ---
        /**
         * Sends a chat message to Firestore.
         */
        async function sendChatMessage() {
            if (!currentUser || !db || !chatMessagesCol || !chatMessageInput) {
                showModal("VocÃª precisa estar logado para enviar mensagens no chat.", "error");
                return;
            }
            const messageText = chatMessageInput.value.trim();
            if (!messageText) return; // Don't send empty messages
            if (containsProhibitedCode(messageText)) {
                showModal("Mensagem contÃ©m cÃ³digo proibido (HTML/JavaScript). Por favor, envie apenas texto.", "error");
                return;
            }

            const userDisplayName = userProfileData?.nickname || userProfileData?.displayName || currentUser.email.split('@')[0];
            const userRole = userProfileData?.role || 'Membro';

            try {
                await addDoc(chatMessagesCol, {
                    userId: currentUserId,
                    displayName: userDisplayName,
                    role: userRole, // Store role for styling messages
                    text: messageText,
                    timestamp: Timestamp.now()
                });
                chatMessageInput.value = ''; // Clear input field
            } catch (error) {
                console.error("Error sending chat message:", error);
                showModal("Erro ao enviar mensagem: " + error.message, "error");
            }
        }

        /**
         * Loads and displays chat messages, and prunes old messages.
         */
        async function loadChatMessages() {
            if (!db || !chatMessagesCol || !chatMessagesContainer) {
                if (chatMessagesContainer) chatMessagesContainer.innerHTML = '<p class="text-xs text-gray-500">Chat indisponÃ­vel.</p>';
                return;
            }
            if (unsubscribeChatMessages) unsubscribeChatMessages(); // Clear previous listener

            // Query for last 30 messages, ordered by timestamp
            const q = query(chatMessagesCol, orderBy("timestamp", "desc"), limit(30));
            unsubscribeChatMessages = onSnapshot(q, async (snapshot) => {
                 // Don't show if user is not logged in AND registrations are closed
                 if (!currentUser && !registrationsOpen) { 
                     chatMessagesContainer.innerHTML = ''; return;
                 }

                const messages = [];
                snapshot.forEach(doc => messages.push({ id: doc.id, ...doc.data() }));
                messages.reverse(); // Reverse to show oldest of the 30 first

                chatMessagesContainer.innerHTML = ''; // Clear previous messages
                if (messages.length === 0) {
                    chatMessagesContainer.innerHTML = '<p class="text-xs text-gray-500 text-center">Nenhuma mensagem ainda. Seja o primeiro!</p>';
                } else {
                    messages.forEach(msg => {
                        const roleColor = currentRoleColors[msg.role] || '#6b7280';
                        const messageDiv = document.createElement('div');
                        messageDiv.className = 'chat-message text-xs';

                        // Delete button: For message author or users with MODERATE_CHAT permission
                        let deleteButtonHtml = '';
                        if (hasPermission(PERMISSIONS.MODERATE_CHAT) || (currentUser && msg.userId === currentUser.uid)) { 
                            deleteButtonHtml = `<button class="delete-chat-msg-btn" data-msg-id="${msg.id}" title="Apagar mensagem">X</button>`;
                        }
                        // Sanitize text to prevent HTML injection
                        const sanitizedText = msg.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

                        messageDiv.innerHTML = `
                            <div>
                                <span class="username user-profile-link cursor-pointer hover:underline" data-userid="${msg.userId}" style="color: ${roleColor};">${msg.displayName}</span>:
                                <span>${sanitizedText}</span>
                            </div>
                            ${deleteButtonHtml}
                        `;
                        chatMessagesContainer.appendChild(messageDiv);
                    });
                    addProfileLinkListeners(chatMessagesContainer); // Add listeners for profile links in chat
                    // Add listeners for delete buttons
                    chatMessagesContainer.querySelectorAll('.delete-chat-msg-btn').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const msgId = e.target.dataset.msgId;
                            const messageToDelete = messages.find(m => m.id === msgId);
                            // Moderator deleting someone else's message requires confirmation
                            if (hasPermission(PERMISSIONS.MODERATE_CHAT) && messageToDelete && messageToDelete.userId !== currentUserId) {
                                confirmAction("Tem certeza que deseja apagar esta mensagem do chat?", () => deleteChatMessage(msgId));
                            } else if (messageToDelete && messageToDelete.userId === currentUserId) { // User deleting their own message
                                deleteChatMessage(msgId); // No confirmation needed
                            }
                        });
                    });
                    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight; // Scroll to bottom
                }

                // Prune old messages if total exceeds a threshold (e.g., 50)
                if (snapshot.docs.length >= 30) { // Only check if we fetched the limit
                    const allMessagesQuery = query(chatMessagesCol, orderBy("timestamp", "asc")); // Get all, oldest first
                    const allMessagesSnap = await getDocs(allMessagesQuery);
                    if (allMessagesSnap.docs.length > 50) { // If more than 50 total
                        // Delete the oldest messages to bring count down to 30 (or desired number)
                        const messagesToDelete = allMessagesSnap.docs.slice(0, allMessagesSnap.docs.length - 30); 
                        for (const docToDelete of messagesToDelete) {
                            try {
                                await deleteDoc(doc(chatMessagesCol, docToDelete.id));
                            } catch (delError) {
                                console.warn("Error pruning old chat message:", delError);
                            }
                        }
                    }
                }

            }, (error) => {
                console.error("Error loading chat messages:", error);
                if(chatMessagesContainer) chatMessagesContainer.innerHTML = '<p class="text-xs text-red-500">Erro ao carregar chat.</p>';
            });
        }
        
        /**
         * Deletes a specific chat message.
         * @param {string} messageId - The ID of the chat message to delete.
         */
        async function deleteChatMessage(messageId) {
            try {
                await deleteDoc(doc(chatMessagesCol, messageId));
                // UI will update via onSnapshot
            } catch (error) {
                console.error("Error deleting chat message:", error);
                showModal("Erro ao apagar mensagem do chat: " + error.message, "error");
            }
        }
        
        // --- Admin Panel: Role Permissions Management ---
        /**
         * Loads and displays the role permission settings in the admin panel.
         * Uses `serverRolePermissionsConfig` which is kept up-to-date by `loadServerConfig`.
         */
        function loadRolePermissionsSettings() { 
            if (!db || !serverConfigDocRef || !hasPermission(PERMISSIONS.MANAGE_ROLES_PERMISSIONS) || !adminPermissionsSettings) {
                if(adminPermissionsSettings) adminPermissionsSettings.innerHTML = ''; // Clear if no permission
                return;
            }
            adminPermissionsSettings.innerHTML = '<p class="text-gray-400">Carregando permissÃµes...</p>';
            
            // User-friendly labels for permissions
            const permissionLabels = {
                [PERMISSIONS.MANAGE_FORUM_SETTINGS]: "Gerenciar Config. FÃ³rum",
                [PERMISSIONS.MANAGE_USERS]: "Gerenciar UsuÃ¡rios",
                [PERMISSIONS.MANAGE_CATEGORIES]: "Gerenciar Categorias",
                [PERMISSIONS.CREATE_TOPIC]: "Criar TÃ³picos",
                [PERMISSIONS.DELETE_OWN_TOPIC]: "Deletar PrÃ³prios TÃ³picos",
                [PERMISSIONS.DELETE_ANY_TOPIC]: "Deletar Qualquer TÃ³pico",
                [PERMISSIONS.CREATE_POST]: "Criar Posts",
                [PERMISSIONS.EDIT_OWN_POST]: "Editar PrÃ³prios Posts",
                [PERMISSIONS.EDIT_ANY_POST]: "Editar Qualquer Post",
                [PERMISSIONS.DELETE_OWN_POST]: "Deletar PrÃ³prios Posts",
                [PERMISSIONS.DELETE_ANY_POST]: "Deletar Qualquer Post",
                [PERMISSIONS.MODERATE_CHAT]: "Moderar Chat",
                [PERMISSIONS.MANAGE_ROLES_PERMISSIONS]: "Gerenciar PermissÃµes de Cargos"
            };

            let html = '<div class="space-y-4">';
            defaultRoles.forEach(role => {
                if (role === 'Admin') return; // Admin permissions are not editable through this UI (always all true)

                html += `<div class="bg-gray-700 p-3 rounded-md">
                            <h5 class="text-md font-semibold text-blue-300 mb-2">${role}</h5>
                            <div class="grid grid-cols-2 sm:grid-cols-3 gap-2">`;
                Object.keys(PERMISSIONS).forEach(permKey => {
                    const permValue = PERMISSIONS[permKey];
                    // Don't show "Manage Roles Permissions" for non-Admin roles, as Admins always have it
                    if (permValue === PERMISSIONS.MANAGE_ROLES_PERMISSIONS && role !== 'Admin') return; 

                    const isChecked = serverRolePermissionsConfig[role] && serverRolePermissionsConfig[role][permValue];
                    html += `
                        <label class="flex items-center space-x-2 text-sm">
                            <input type="checkbox" id="perm-${role}-${permValue}" data-role="${role}" data-permission="${permValue}" 
                                class="form-checkbox h-4 w-4 text-blue-500 bg-gray-600 border-gray-500 rounded focus:ring-blue-400" 
                                ${isChecked ? 'checked' : ''}>
                            <span>${permissionLabels[permValue] || permValue}</span>
                        </label>
                    `;
                });
                html += `</div></div>`;
            });
            html += '</div>';
            adminPermissionsSettings.innerHTML = html;
        }

        /**
         * Saves role permissions from the admin panel to Firestore.
         */
        async function saveRolePermissions() {
            if (!hasPermission(PERMISSIONS.MANAGE_ROLES_PERMISSIONS)) {
                showModal("VocÃª nÃ£o tem permissÃ£o para gerenciar permissÃµes.", "error"); return;
            }

            // Create a deep copy to modify, ensuring Admin role retains all permissions
            const newPermissionsConfig = JSON.parse(JSON.stringify(serverRolePermissionsConfig)); 

            defaultRoles.forEach(role => {
                if (role === 'Admin') { // Ensure Admin role always has all permissions
                    newPermissionsConfig[role] = {}; // Reset and reassign
                    Object.values(PERMISSIONS).forEach(permValue => {
                        newPermissionsConfig[role][permValue] = true;
                    });
                    return; 
                }
                
                if (!newPermissionsConfig[role]) newPermissionsConfig[role] = {}; // Initialize if role is new
                
                // Update permissions based on checkbox states
                Object.values(PERMISSIONS).forEach(permValue => {
                    const checkbox = document.getElementById(`perm-${role}-${permValue}`);
                    if (checkbox) { // If checkbox exists for this perm and role
                        newPermissionsConfig[role][permValue] = checkbox.checked;
                    } 
                    // If checkbox doesn't exist (e.g. MANAGE_ROLES_PERMISSIONS for non-Admin), it won't be changed
                });
            });

            try {
                await setDoc(serverConfigDocRef, { rolePermissions: newPermissionsConfig }, { merge: true });
                showModal("PermissÃµes dos cargos salvas com sucesso!", "success");
                // `serverRolePermissionsConfig` and `currentRolePermissions` will be updated by `loadServerConfig` onSnapshot.
            } catch (error) {
                console.error("Error saving role permissions:", error);
                showModal("Erro ao salvar permissÃµes: " + error.message, "error");
            }
        }


        // --- Modal & Confirmation Dialogs ---
        const messageModal = document.getElementById('message-modal');
        const messageModalText = document.getElementById('message-modal-text');
        const messageModalClose = document.getElementById('message-modal-close');

        /**
         * Shows a generic message modal.
         * @param {string} message - The message to display.
         * @param {string} type - "info", "success", or "error" for styling.
         */
        function showModal(message, type = "info") { 
            if (!messageModal || !messageModalText) { // Fallback if modal elements aren't found
                console.warn("Message modal elements not found. Message:", message);
                if (type === "error") console.error(message);
                else if (type === "success") console.log("SUCCESS:", message);
                else console.info(message);
                return;
            }
            messageModalText.textContent = message;
            messageModalText.className = 'mb-4 '; // Reset classes
            if (type === "error") messageModalText.classList.add('text-red-700');
            else if (type === "success") messageModalText.classList.add('text-green-700');
            else messageModalText.classList.add('text-blue-700'); // Default to info style
            messageModal.style.display = 'flex'; // Show modal
        }
        if (messageModalClose) messageModalClose.onclick = () => messageModal.style.display = 'none';
        
        // Close modals if clicked outside their content area
        window.onclick = (event) => { 
            if (event.target == messageModal) messageModal.style.display = 'none';
            
            const createTopicModalElem = document.getElementById('create-topic-modal');
            if (createTopicModalElem && event.target == createTopicModalElem) createTopicModalElem.style.display = 'none';
            
            const confirmActionModalElem = document.getElementById('confirm-action-modal');
            if (confirmActionModalElem && event.target == confirmActionModalElem) confirmActionModalElem.style.display = 'none';
            
            if (csServerModal && event.target == csServerModal) csServerModal.style.display = 'none';
            if (editPostModal && event.target == editPostModal) editPostModal.style.display = 'none';
            if (editTopicModal && event.target == editTopicModal) editTopicModal.style.display = 'none';
        }

        // Confirmation Modal elements and logic
        const confirmModal = document.getElementById('confirm-action-modal');
        const confirmModalText = document.getElementById('confirm-action-text');
        const confirmModalYes = document.getElementById('confirm-action-yes');
        const confirmModalNo = document.getElementById('confirm-action-no');
        let confirmCallback = null; // Stores the function to call if "Yes" is clicked

        /**
         * Shows a confirmation dialog.
         * @param {string} message - The confirmation message.
         * @param {Function} callback - The function to execute if confirmed.
         */
        function confirmAction(message, callback) {
            if (!confirmModal || !confirmModalText) { // Fallback if modal not found
                console.warn("Confirm modal elements not found. Action:", message);
                // For critical actions, you might want to prevent the action if confirmation isn't possible.
                // However, for this example, we'll log and not proceed.
                console.error("Confirmation modal not available for: " + message + ". Action NOT performed.");
                return;
            }
            confirmModalText.textContent = message;
            confirmCallback = callback;
            confirmModal.style.display = 'flex'; // Show modal
        }
        if (confirmModalYes) confirmModalYes.onclick = () => {
            if (confirmCallback) confirmCallback(); // Execute the stored callback
            confirmModal.style.display = 'none'; // Hide modal
            confirmCallback = null; // Clear callback
        };
        if (confirmModalNo) confirmModalNo.onclick = () => {
            confirmModal.style.display = 'none'; // Hide modal
            confirmCallback = null; // Clear callback
        };

        /**
         * FunÃ§Ã£o utilitÃ¡ria para detectar cÃ³digo HTML/JS proibido em mensagens/posts.
         * Retorna true se encontrar cÃ³digo proibido.
         */
        function containsProhibitedCode(text) {
            if (!text) return false;
            // Regex para detectar tags HTML perigosas ou javascript:
            const forbiddenPattern = /<\s*(script|iframe|img|object|embed|svg|link|style|meta|form|input|textarea|button)[^>]*>|javascript\s*:/i;
            return forbiddenPattern.test(text);
        }

        // --- VariÃ¡veis para comandos dinÃ¢micos no tÃ³pico ---
        let topicCommands = [];
        let topicCommandsListDiv = null;
        let addTopicCommandBtn = null;

        // FunÃ§Ã£o para renderizar a lista de comandos no modal
        function renderTopicCommandsList() {
            if (!topicCommandsListDiv) return;
            topicCommandsListDiv.innerHTML = '';
            topicCommands.forEach((cmd, idx) => {
                const cmdDiv = document.createElement('div');
                cmdDiv.className = 'flex items-center space-x-2 mb-2';
                cmdDiv.innerHTML = `
                    <input type="text" placeholder="Nome (ex: Steam, Script)" value="${cmd.nome || ''}" class="command-nome-input p-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 text-sm w-32" data-idx="${idx}">
                    <input type="text" placeholder="Comando" value="${cmd.comando || ''}" class="command-comando-input p-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 text-sm flex-1" data-idx="${idx}">
                    <button type="button" class="remove-topic-command-btn bg-red-600 hover:bg-red-700 text-white rounded-md px-2 py-1 text-xs" data-idx="${idx}">Remover</button>
                `;
                topicCommandsListDiv.appendChild(cmdDiv);
            });
        }

        // Adiciona um comando vazio
        function addTopicCommand() {
            topicCommands.push({ nome: '', comando: '' });
            renderTopicCommandsList();
        }

        // Remove comando pelo Ã­ndice
        function removeTopicCommand(idx) {
            topicCommands.splice(idx, 1);
            renderTopicCommandsList();
        }

        // Atualiza valor dos inputs
        function updateTopicCommandInput(e) {
            const idx = parseInt(e.target.dataset.idx);
            if (e.target.classList.contains('command-nome-input')) {
                topicCommands[idx].nome = e.target.value;
            } else if (e.target.classList.contains('command-comando-input')) {
                topicCommands[idx].comando = e.target.value;
            }
        }

        // Inicializa eventos ao abrir modal de criar tÃ³pico
        document.addEventListener('DOMContentLoaded', () => {
            topicCommandsListDiv = document.getElementById('topic-commands-list');
            addTopicCommandBtn = document.getElementById('add-topic-command-btn');
            if (addTopicCommandBtn) {
                addTopicCommandBtn.addEventListener('click', addTopicCommand);
            }
            // DelegaÃ§Ã£o para remover e editar
            if (topicCommandsListDiv) {
                topicCommandsListDiv.addEventListener('click', function(e) {
                    if (e.target.classList.contains('remove-topic-command-btn')) {
                        const idx = parseInt(e.target.dataset.idx);
                        removeTopicCommand(idx);
                    }
                });
                topicCommandsListDiv.addEventListener('input', updateTopicCommandInput);
            }
        });

       

    </script>

    <header class="bg-gray-800 shadow-md p-4">
        <div class="container mx-auto flex flex-col sm:flex-row justify-between items-center">
            <h1 id="forum-title-header" class="text-3xl font-bold text-blue-500 mb-2 sm:mb-0">Negativa Server - FÃ³rum</h1>
            <nav class="space-x-2 sm:space-x-4 text-sm sm:text-base">
                <span id="user-display" class="text-sm"></span>
                <span id="current-user-id-display" class="text-xs text-gray-400" style="display:none;"></span>
                <a href="#" id="admin-panel-nav" class="text-yellow-400 hover:text-yellow-300" style="display:none;">Painel Admin</a>
                <a href="#" id="my-profile-nav" class="text-blue-400 hover:text-blue-300" style="display:none;">Meu Perfil</a>
                <a href="#" id="login-nav" class="text-blue-400 hover:text-blue-300">Login</a>
                <a href="#" id="register-nav" class="text-blue-400 hover:text-blue-300" style="display:none;">Registrar</a>
                <a href="#" id="logout-nav" class="text-blue-400 hover:text-blue-300" style="display:none;">Logout</a>
            </nav>
        </div>
        <div id="breadcrumbs" class="container mx-auto text-sm text-gray-400 mt-2 px-4 sm:px-0">
            <a href="#" data-view="forumHome" class="hover:text-blue-300">InÃ­cio</a>
        </div>
    </header>

    <div id="server-info-banner-container" class="container mx-auto mt-4 space-y-2">
        </div>


    <main id="main-content" class="container mx-auto p-4">
        <div id="loading-view" class="view active-view text-center py-10">
            <div class="loading-spinner"></div>
            <p class="text-xl text-gray-300">Carregando...</p>
        </div>

        <div id="login-view" class="view max-w-md mx-auto bg-gray-800 p-8 rounded-lg shadow-xl">
            <h2 class="text-2xl font-semibold mb-6 text-center text-blue-400">Login</h2>
            <form id="login-form">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm font-medium text-gray-300 mb-1">Email</label>
                    <input type="email" id="login-email" name="email" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400" placeholder="seu@email.com">
                </div>
                <div class="mb-6">
                    <label for="login-password" class="block text-sm font-medium text-gray-300 mb-1">Senha</label>
                    <input type="password" id="login-password" name="password" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100" placeholder="********">
                </div>
                <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-4 rounded-md transition duration-150">Entrar</button>
            </form>
            <p id="register-prompt-container" class="text-center mt-4 text-sm">NÃ£o tem uma conta? <a href="#" id="show-register-view" class="text-blue-400 hover:underline">Registre-se</a></p>
        </div>

        <div id="register-view" class="view max-w-md mx-auto bg-gray-800 p-8 rounded-lg shadow-xl">
            <h2 class="text-2xl font-semibold mb-6 text-center text-blue-400">Registrar Nova Conta</h2>
            <form id="register-form">
                <div class="mb-4">
                    <label for="register-email" class="block text-sm font-medium text-gray-300 mb-1">Email</label>
                    <input type="email" id="register-email" name="email" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400" placeholder="seu@email.com">
                </div>
                <div class="mb-4">
                    <label for="register-password" class="block text-sm font-medium text-gray-300 mb-1">Senha</label>
                    <input type="password" id="register-password" name="password" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100" placeholder="********">
                </div>
                <div class="mb-6">
                    <label for="register-confirmPassword" class="block text-sm font-medium text-gray-300 mb-1">Confirmar Senha</label>
                    <input type="password" id="register-confirmPassword" name="confirmPassword" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100" placeholder="********">
                </div>
                <button type="submit" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-md transition duration-150">Registrar</button>
            </form>
            <p class="text-center mt-4 text-sm">JÃ¡ tem uma conta? <a href="#" id="show-login-view" class="text-blue-400 hover:underline">FaÃ§a Login</a></p>
        </div>

        <div id="forum-home-view" class="view">
            <div id="admin-controls" class="mb-6 bg-gray-800 p-6 rounded-lg shadow-md" style="display:none;">
                <h3 class="text-2xl font-bold mb-6 text-yellow-500 border-b border-gray-700 pb-3">Painel do Administrador</h3>
                
                <div class="admin-section">
                    <h4 class="admin-section-title">ConfiguraÃ§Ãµes Gerais do FÃ³rum</h4>
                    <div class="space-y-4">
                        <div>
                            <label for="admin-forum-name" class="block text-sm font-medium text-gray-300 mb-1">Nome do FÃ³rum</label>
                            <input type="text" id="admin-forum-name" class="w-full p-2 bg-gray-600 border border-gray-500 rounded-md text-gray-100 placeholder-gray-400">
                        </div>
                         <div class="flex items-center">
                            <label for="admin-registrations-toggle" class="block text-sm font-medium text-gray-300 mr-3">Permitir Novos Cadastros:</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="admin-registrations-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="flex space-x-3">
                            <button id="save-forum-name-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Salvar Nome</button>
                            <button id="save-registration-settings-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Salvar Config. Cadastro</button>
                        </div>
                    </div>
                </div>

                <div class="admin-section">
                    <h4 class="admin-section-title">Criar Nova Categoria</h4>
                    <form id="create-category-form" class="space-y-4">
                        <div>
                            <label for="category-name" class="block text-sm font-medium text-gray-300 mb-1">Nome da Categoria</label>
                            <input type="text" id="category-name" name="name" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400">
                        </div>
                        <div class="mb-2">
                            <label for="category-description" class="block text-sm font-medium text-gray-300 mb-1">DescriÃ§Ã£o</label>
                            <textarea id="category-description" name="description" rows="2" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400"></textarea>
                        </div>
                        <div class="mt-2 mb-2">
                            <label class="block text-sm font-medium text-gray-300 mb-1">Permitir visualizaÃ§Ã£o para os cargos (deixe desmarcado para pÃºblico):</label>
                            <div id="category-role-permissions-admin-container">
                                </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button type="submit" class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold py-2 px-4 rounded-md transition duration-150">Criar Categoria</button>
                            <button type="button" id="generate-category-description-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-md transition duration-150 text-sm">
                                Gerar DescriÃ§Ã£o com IA â¨
                            </button>
                            <div id="generate-category-desc-spinner" class="gemini-loading-spinner" style="display:none;"></div>
                        </div>
                    </form>
                </div>

                <div class="admin-section">
                    <h4 class="admin-section-title">Configurar Servidores CS2</h4>
                    <div id="cs-servers-list-admin" class="space-y-2 mb-3">
                        </div>
                    <button id="add-cs-server-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Adicionar Servidor CS2</button>
                </div>

                <div class="admin-section">
                    <h4 class="admin-section-title">ConfiguraÃ§Ãµes de Cores dos Cargos</h4>
                    <div id="admin-role-color-settings" class="space-y-2">
                        </div>
                    <button id="save-role-colors-btn" class="mt-3 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Salvar Cores dos Cargos</button>
                </div>
                
                <div class="admin-section">
                    <h4 class="admin-section-title">PermissÃµes dos Cargos</h4>
                    <div id="admin-permissions-settings" class="space-y-4">
                        </div>
                    <button id="save-permissions-btn" class="mt-3 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Salvar PermissÃµes</button>
                </div>

                <div class="admin-section">
                    <h4 class="admin-section-title">Gerenciamento de UsuÃ¡rios</h4>
                    <div id="admin-user-list" class="space-y-3 max-h-96 overflow-y-auto">
                        </div>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div class="md:col-span-3">
                    <h2 class="text-2xl font-semibold mb-6 text-blue-400">Categorias</h2>
                    <div id="categories-list" class="space-y-4">
                        </div>
                </div>
                <aside class="md:col-span-1 bg-gray-800 p-4 rounded-lg shadow-md">
                    <div id="recent-members-list">
                        <p class="text-gray-400">Carregando membros recentes...</p>
                    </div>
                    <div class="mt-6 pt-4 border-t border-gray-700">
                        <h4 class="text-md font-semibold text-gray-300 mb-2">Chat RÃ¡pido</h4>
                        <div id="chat-messages" class="bg-gray-700 p-2 rounded h-48 overflow-y-auto text-xs mb-2">
                            </div>
                        <div class="flex">
                            <input type="text" id="chat-message-input" class="flex-grow p-2 bg-gray-600 border border-gray-500 rounded-l-md text-gray-100 placeholder-gray-400 text-sm" placeholder="Digite sua mensagem...">
                            <button id="send-chat-message-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-3 rounded-r-md text-sm">Enviar</button>
                        </div>
                    </div>
                </aside>
            </div>
        </div>

        <div id="category-view" class="view">
            <div class="flex justify-between items-center mb-6">
                <h2 id="category-title" class="text-2xl font-semibold text-blue-400"></h2>
                <button id="show-create-topic-modal" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150">Novo TÃ³pico</button>
            </div>
            <div id="topics-list" class="space-y-3">
                </div>
        </div>

        <div id="topic-view" class="view">
            <h2 id="topic-title-full" class="text-2xl font-semibold mb-6 text-blue-400"></h2>
            <div id="topic-poll-container" class="mb-6">
                </div>
            <div id="posts-list" class="mb-6">
                </div>
            <form id="create-post-form" class="bg-gray-800 p-6 rounded-lg shadow-md">
                <h3 class="text-xl font-semibold mb-4 text-gray-200">Responder ao TÃ³pico</h3>
                <div>
                    <label for="post-content" class="block text-sm font-medium text-gray-300 mb-1">Sua Mensagem</label>
                    <textarea id="post-content" name="content" rows="5" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400"></textarea>
                </div>
                <button type="submit" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150">Enviar Resposta</button>
            </form>
        </div>

        <div id="my-profile-view" class="view max-w-lg mx-auto bg-gray-800 p-8 rounded-lg shadow-xl">
            <h2 class="text-2xl font-semibold mb-6 text-center text-blue-400">Meu Perfil</h2>
            <div class="mb-4">
                <label for="my-profile-nickname" class="block text-sm font-medium text-gray-300 mb-1">Nickname (Apelido)</label>
                <input type="text" id="my-profile-nickname" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400">
            </div>
            <div class="mb-4">
                <label for="my-profile-steam-url" class="block text-sm font-medium text-gray-300 mb-1">URL do Perfil Steam (Opcional)</label>
                <input type="url" id="my-profile-steam-url" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400" placeholder="https://steamcommunity.com/id/seu_id_ou_profile/123...">
            </div>
            <div class="mb-4">
                <p class="text-sm text-gray-400">Email: <span id="my-profile-email" class="text-gray-200"></span></p>
            </div>
            <div class="mb-6">
                <p class="text-sm text-gray-400">Cargo: <span id="my-profile-role" class="text-gray-200"></span></p>
            </div>
            <button id="my-profile-save-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-md transition duration-150">Salvar AlteraÃ§Ãµes</button>
        </div>

        <div id="user-profile-view" class="view max-w-lg mx-auto bg-gray-800 p-8 rounded-lg shadow-xl">
            <h2 class="text-2xl font-semibold mb-6 text-center text-blue-400">Perfil de UsuÃ¡rio</h2>
            <div class="space-y-3">
                <p><strong class="text-gray-400">Nome de ExibiÃ§Ã£o:</strong> <span id="user-profile-view-displayName" class="text-gray-200"></span></p>
                <p><strong class="text-gray-400">Nickname:</strong> <span id="user-profile-view-nickname" class="text-gray-200"></span></p>
                <p><strong class="text-gray-400">Email:</strong> <span id="user-profile-view-email" class="text-gray-200"></span></p>
                <p><strong class="text-gray-400">Cargo:</strong> <span id="user-profile-view-role" class="text-gray-200"></span></p>
                <p style="display:none;"><strong class="text-gray-400">Perfil Steam:</strong> <a id="user-profile-view-steam-link" href="#" target="_blank" class="text-blue-400 hover:underline"></a></p>
                <p><strong class="text-gray-400">Registrado em:</strong> <span id="user-profile-view-registered-date" class="text-gray-200"></span></p>
            </div>
            <button id="back-to-forum-from-profile" class="mt-6 w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-md transition duration-150">Voltar ao FÃ³rum</button>
        </div>


    </main>

    <footer class="bg-gray-800 text-center p-4 mt-8">
        <p class="text-sm text-gray-500">&copy; Negativa Server. Todos os direitos reservados.</p>
    </footer>

    <div id="message-modal" class="modal" style="display:none;">
        <div class="modal-content bg-gray-100 text-gray-800 rounded-lg shadow-xl">
            <span id="message-modal-close" class="modal-close">&times;</span>
            <p id="message-modal-text" class="mb-4"></p>
            <button onclick="document.getElementById('message-modal').style.display='none'" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded w-full">OK</button>
        </div>
    </div>

    <div id="create-topic-modal" class="modal" style="display:none;">
        <div class="modal-content modal-content-lg bg-gray-800 text-gray-100 p-6 rounded-lg shadow-xl w-full">
            <h3 class="text-xl font-semibold mb-4 text-blue-400">Criar Novo TÃ³pico</h3>
            <form id="create-topic-form-modal">
                <div class="mb-4">
                    <label for="new-topic-title" class="block text-sm font-medium text-gray-300 mb-1">TÃ­tulo do TÃ³pico</label>
                    <input type="text" id="new-topic-title" name="title" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400">
                </div>
                <div class="mb-4">
                    <label for="new-topic-content" class="block text-sm font-medium text-gray-300 mb-1">ConteÃºdo da Primeira Postagem</label>
                    <textarea id="new-topic-content" name="content" rows="5" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400"></textarea>
                </div>
                <div class="mb-4">
                    <label for="new-topic-command" class="block text-sm font-medium text-gray-300 mb-1">Comando para Copiar (Opcional)</label>
                    <input type="text" id="new-topic-command" name="commandToCopy" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400" placeholder="Ex: connect seu.ip.aqui:porta">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-300 mb-1">Permitir visualizaÃ§Ã£o para os cargos (deixe desmarcado para herdar da categoria/pÃºblico):</label>
                    <div id="topic-role-permissions-container">
                        </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-300 mb-1">Comandos para Copiar (Opcional)</label>
                    <div id="topic-commands-list"></div>
                    <button type="button" id="add-topic-command-btn" class="mt-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-3 rounded-md text-sm">Adicionar Comando</button>
                </div>

                <div class="flex justify-end space-x-3 items-center">
                    <button type="button" id="suggest-topic-title-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-md transition duration-150 text-sm">
                        Sugerir TÃ­tulo com IA â¨
                    </button>
                    <div id="suggest-topic-title-spinner" class="gemini-loading-spinner" style="display:none;"></div>
                    <button type="button" id="cancel-create-topic" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-md transition duration-150">Cancelar</button>
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150">Criar TÃ³pico</button>
                </div>
            </form>
        </div>
    </div>

    <div id="edit-topic-modal" class="modal" style="display:none;">
        <div class="modal-content modal-content-lg bg-gray-800 text-gray-100 p-6 rounded-lg shadow-xl w-full">
            <h3 class="text-xl font-semibold mb-4 text-blue-400">Editar TÃ³pico</h3>
            <form id="edit-topic-form-modal"> <div class="mb-4">
                    <label for="edit-topic-title" class="block text-sm font-medium text-gray-300 mb-1">TÃ­tulo do TÃ³pico</label>
                    <input type="text" id="edit-topic-title" name="title" required class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 text-gray-100 placeholder-gray-400">
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-300 mb-1">Permitir visualizaÃ§Ã£o para os cargos (deixe desmarcado para herdar da categoria/pÃºblico):</label>
                    <div id="edit-topic-role-permissions-container">
                        </div>
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" id="cancel-edit-topic-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-md">Cancelar</button>
                    <button type="button" id="save-edit-topic-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md">Salvar AlteraÃ§Ãµes</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="confirm-action-modal" class="modal" style="display:none;">
        <div class="modal-content bg-gray-100 text-gray-800 p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-lg font-semibold mb-4 text-yellow-500">Confirmar AÃ§Ã£o</h3>
            <p id="confirm-action-text" class="mb-6 text-gray-700"></p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-action-no" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150">NÃ£o</button>
                <button id="confirm-action-yes" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md transition duration-150">Sim</button>
            </div>
        </div>
    </div>

    <div id="cs-server-modal" class="modal" style="display:none;">
        <div class="modal-content bg-gray-800 text-gray-100 p-6 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-semibold mb-4 text-blue-400">Configurar Servidor CS2</h3>
            <form id="cs-server-form">
                <input type="hidden" id="cs-server-id"> <div class="mb-4">
                    <label for="cs-server-name" class="block text-sm font-medium text-gray-300 mb-1">Nome de ExibiÃ§Ã£o do Servidor</label>
                    <input type="text" id="cs-server-name" required class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400">
                </div>
                <div class="mb-4">
                    <label for="cs-server-connect" class="block text-sm font-medium text-gray-300 mb-1">Comando de ConexÃ£o (ex: connect 127.0.0.1:27015)</label>
                    <input type="text" id="cs-server-connect" required class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400">
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" id="cancel-cs-server" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-md">Cancelar</button>
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md">Salvar Servidor</button>
                </div>
            </form>
        </div>
    </div>

    <div id="edit-post-modal" class="modal" style="display:none;">
        <div class="modal-content bg-gray-800 text-gray-100 p-6 rounded-lg shadow-xl w-full max-w-lg">
            <h3 class="text-xl font-semibold mb-4 text-blue-400">Editar Postagem</h3>
            <textarea id="edit-post-content" rows="8" class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-gray-100 placeholder-gray-400 mb-4"></textarea>
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancel-edit-post-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-md">Cancelar</button>
                <button type="button" id="save-edit-post-btn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md">Salvar EdiÃ§Ã£o</button>
            </div>
        </div>
    </div>

</body>
</html>
